dirver.c
	int main(){
		int res=asm_main();		
		return 0;
	}

ejercicio1.asm

segment .data	//Variables inicializadas

segment .bss	//Las variables no inicializada

segment .txt	//Donde comienza el código

global asm_main

asm_main:


ter	

Para compilar:
nasm -f elf ejercicio1.asm -> ejercicio.o
gcc driver.c ejercicio1.o -> a.out
gcc driver.c ejercicio1.o -o prueba //para darle nombre


IMPORTANTE: Es necesario instalar gcc-miltilib con el comando sudo apt-get install gcc-multilib
Luego de esto es necesario alcarar que vamos a hacer uso de las librerias de 32bit con -m32. 

Luego hicimos uso de la dump_regs 332. Para ello incluimos la librería "asm_io.inc", y para compilar, tuvimos que aclarar el uso de esa librería también.
gcc driver.c ejercicio1.o asm_io.o -o prueba -m32
	

Luego apareció otro error y tuvimos que ejecutar el siguiente comando:
	nasm -f elf -d ELF_TYPE asm_io.asm 

El linker es el que se encarga de juntar todos los archivos .o.

Para avisarle al linker que funcion vamos a usar es con global

cosas principales de asm:

Registros: eax--ax--ah.al
el eax lo podemos ver en 4bytes
registros A,B,C,D
Con esto no alcanza para realizar todos los cálculos, necesitamos la Memoria.

¿Como se direcciona la memoria? La memoria siempre es 1Byte.
CUando opero lo hago entre registros y memoria.
Para reservar memoria lo hago en el .data o en el .bss
L1 es una direccion de memoria que sera del tipo 0FF...
¿Qué son los nombres como L1? Son punteros, como los de pascal. Si hablo de L1 hablo del valor de direccion de memoria. Si quiero 
hablar de lo que está adentro, uso []. [L1] se llama indirecta. La otra forma es directa, cuando tengo solo L1, si le paso un 1 es imediato.
Ejemplo: Si tenemos 8 en L1
 MOV EAX [L1]  movemos a EAX el 8. Pasa 1 byte a un registros EAX de 4bytes, los otros 3bytes, se rellenan con los 3bytes que le siguen a L1.

sI L1 es un word(2bytes) que tiene almacenado por ejemplo 8 8, y paso eso a un AL, que tiene 1byte, entonces se almacena en AL el primer 8, y el otro se pierde.

