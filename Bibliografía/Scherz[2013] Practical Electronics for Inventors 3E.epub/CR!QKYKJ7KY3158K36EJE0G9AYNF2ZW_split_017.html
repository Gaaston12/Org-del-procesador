<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Practical Electronics for Inventors, Third Edition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="filepos2660694" class="calibre3"><span class="calibre7"><span><a></a><span class="bold">12.2   Logic Gates</span></span></span></div>
<div class="calibre11"><span><img alt="image" src="images/00007.jpg" class="calibre2"/></span></div>
<div class="calibre11"><span>Logic gates are the building blocks of digital electronics. The fundamental logic gates include the INVERT (NOT), AND, NAND, OR, NOR, exclusive OR (XOR), and exclusive NOR (XNOR) gates. Each of these gates performs a different logical operation. <a href="#filepos2661466">Figure 12.10</a> provides a description of what each logic gate does and gives a switch and transistor analogy for each gate.</span></div>
<div id="filepos2661466" class="calibre3"><span><img alt="image" src="images/01674.jpg" class="calibre2"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.10</span></span></span></div><div class="calibre35"> </div>
<div id="filepos2661717" class="calibre3"><span class="bold"><span class="italic"><span><a></a><span class="bold"><span class="italic">12.2.1   Multiple-Input Logic Gates</span></span></span></span></span></div>
<div class="calibre11"><span>AND, NAND, OR, and NOR gates often come with more than two inputs (this is not the case with XOR and XNOR gates, which require two inputs only). <a href="#filepos2662438">Figure 12.11</a> shows a four-input AND, an eight-input AND, a three-input OR, and an eight-input OR gate. With the eight-input AND gate, all inputs must be high for the output to be high. With the eight-input OR gate, at least one of the inputs must be high for the output to go high.</span></div>
<div id="filepos2662438" class="calibre3"><span><img alt="image" src="images/01675.jpg" class="calibre2"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.11</span></span></span></div><div class="calibre35"> </div>
<div id="filepos2662689" class="calibre3"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.2.2   Digital Logic Gate ICs</span></span></span></span></span></div>
<div class="calibre11"><span>The construction of digital gates is best left to the IC manufacturers. In fact, making gates from discrete components is highly impractical in regard to both overall performance (power consumption, speed, drive capacity, and so on) and overall cost and size.</span></div>
<div class="calibre26"><span>As we mentioned in the introduction to this chapter, the use of individual logic ICs has almost completely been superseded by the use of microcontrollers. However, one or two logic ICs are still often used together in simple applications.</span></div>
<div class="calibre26"><span>There are a number of technologies used in the fabrication of digital logic. The two most popular technologies include transistor-transistor logic (TTL) and complementary MOSFET (CMOS) logic. TTL incorporates bipolar transistors into its design, while CMOS incorporates MOSFET transistors. Both technologies perform the same basic functions, but certain characteristics (such as power consumption, speed, and output drive capacity) differ. There are many subfamilies within both TTL and CMOS. These subfamilies, as well as the various characteristics associated with each subfamily, will be discussed in greater detail in <a href="#filepos2748176">Section 12.4</a>.</span></div>
<div class="calibre26"><span>A logic IC, be it TTL or CMOS, typically houses more than one logic gate (for example, a quad two-input NAND, hex inverter, and so on). Each of the gates within the IC shares a common supply voltage that is implemented via two supply pins: a positive supply pin (+<span class="italic">V</span><sub class="calibre37"><small class="calibre28"><span class="calibre17"><span class="italic">CC</span></span></small></sub> or +<span class="italic">V<sub class="calibre37"><small class="calibre28"><span class="calibre17">DD</span></small></sub></span>) and a ground pin (GND). The vast majority of TTL and CMOS ICs are designed to run off a +5-V supply. (This does not apply for all the logic families, but I will get to that in <a href="#filepos2748176">Section 12.4</a>.)</span></div>
<div class="calibre26"><span><a></a>Generally speaking, input and output voltage levels are assumed to be 0 <span class="italic">V</span> (low) and +5 <span class="italic">V</span> (high). However, the actual input voltage required and the actual output voltage provided by the gate are not set in stone. For example, the 74<span class="italic">xx</span> TTL series will recognize a high input from 2.0 to 5 <span class="italic">V</span> and a low from 0 to 0.8 <span class="italic">V</span>, and will guarantee a high output from 2.4 to 5 <span class="italic">V</span> and a low output from 0 to 0.4 <span class="italic">V</span>. However, for the CMOS 4000B series (<span class="italic">V<sub class="calibre37"><small class="calibre28"><span class="calibre17">CC</span></small></sub></span> = +5 <span class="italic">V</span>), recognizable input voltages range from 3.3 to 5 <span class="italic">V</span> for high and 0 to 1.7 <span class="italic">V</span> for low. Guaranteed high and low output levels range from 4.9 to 5 <span class="italic">V</span> and 0 to 0.1 <span class="italic">V</span>, respectively. Again, I will discuss specifics later in <a href="#filepos2748176">Section 12.4</a>. For now, let’s just get acquainted with what some of these ICs look like, as shown in <a href="#filepos2666243">Figs. 12.12</a> and <a href="#filepos2666494">12.13</a>. The CMOS devices listed in the figures include 74H<span class="italic">Cxx</span> and 4000(B). The TTL devices shown include the 74<span class="italic">xx</span>, 74F<span class="italic">xx</span>, and 74LS.</span></div>
<div id="filepos2666243" class="calibre3"><span><img alt="image" src="images/01676.jpg" class="calibre2"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.12</span></span></span></div><div class="calibre35"> </div>
<div id="filepos2666494" class="calibre3"><span><img alt="image" src="images/01677.jpg" class="calibre2"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.13</span></span></span></div><div class="calibre35"> </div>
<div id="filepos2666745" class="calibre3"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.2.3   Applications for a Single Logic Gate</span></span></span></span></span></div>
<div class="calibre11"><span>Before we jump into the heart of logic gate applications that involve combining logic gates to form complex decision-making circuits, let’s take a look at a few simple applications that require the use of a single logic gate.</span></div>
<div class="calibre3"><span><a></a><span class="bold">Enable/Disable Control</span></span></div>
<div class="calibre11"><span>An enable/disable gate is a logic gate that acts to control the passage of a given waveform. The waveform—say, a clock signal—is applied to one of the gate’s inputs, while the other input acts as the enable/disable control lead. Enable/disable gates are used frequently in digital systems to enable and disable control information from reaching various devices. <a href="#filepos2668039">Figure 12.14</a> shows two enable/disable circuits: the first uses an AND gate, and the second uses an OR gate. NAND and NOR gates are also frequently used as enable gates.</span></div>
<div id="filepos2668039" class="calibre3"><span><img alt="image" src="images/01678.jpg" class="calibre2"/></span></div>
<div class="calibre6"><span class="calibre17"><span class="bold"><span>In the upper part of the figure, an AND gate acts as the enable gate. When the input enable lead is made high, the clock signal will pass to the output. In this example, the input enable is held high for 4 μ<span class="italic">s</span>, allowing 4 clock pulses (where <span class="italic">T</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">clk</span></small></sub> = 1 μ<span class="italic">s</span>) to pass. When the input enable lead is low, the gate is disabled, and no clock pulses make it through to the output.</span></span></span></div>
<div class="calibre26"><span class="calibre17"><span class="bold"><span>Below, an OR gate is used as the enable gate. The output is held high when the input enable lead is high, even as the clock signal is varying. However, when the enable input is low, the clock pulses are passed to the output.</span></span></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.14</span></span></span></div><div class="calibre35"> </div>
<div class="calibre3"><span><span class="bold">Waveform Generation</span></span></div>
<div class="calibre11"><span>By using the basic enable/disable function of a logic gate, as illustrated in the previous example, it is possible, with the help of a repetitive waveform generator circuit, to create specialized waveforms that can be used for the digital control of sequencing circuits.</span></div>
<div class="calibre26"><span><a></a>An example waveform generator circuit is the Johnson counter. The Johnson counter will be discussed in <a href="CR%21QKYKJ7KY3158K36EJE0G9AYNF2ZW_split_018.html#filepos2898449">Section 12.8</a>. For now, let’s simply focus on the outputs. In <a href="#filepos2670511">Fig. 12.15</a>, a Johnson counter uses clock pulses to generate different output waveforms, as shown in the timing diagram. Outputs <span class="italic">A, B, C</span>, and <span class="italic">D</span> go high for 4 μs (four clock periods) and are offset from each other by 1 μs. Outputs <span class="italic"><img alt="image" src="images/01679.jpg" class="calibre2"/>, <img alt="image" src="images/01680.jpg" class="calibre2"/>, <img alt="image" src="images/01681.jpg" class="calibre2"/></span>, and <img alt="image" src="images/01682.jpg" class="calibre2"/> produce waveforms that are complements of outputs <span class="italic">A, B, C</span>, and <span class="italic">D</span>, respectively.</span></div>
<div id="filepos2670511" class="calibre3"><span><img alt="image" src="images/01683.jpg" class="calibre2"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.15</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>Now, there may be certain applications that require 4-μs high/low pulses applied at a given time, as the counter provides. However, what would you do if the application requires a 3-μs high waveform that begins at 2 μs and ends at 5 μs (relative to the time scale indicated in <a href="#filepos2670511">Fig. 12.15</a>)? This is where the logic gates come in handy. For example, if you attach an AND gate’s inputs to the counter’s <span class="italic">A</span> and <span class="italic">B</span> outputs, you will get the desired 2- to 5-μs high waveform at the AND gate’s output: from 1 to 2 μs the AND gate outputs a low (<span class="italic">A</span> = 1, <span class="italic">B</span> = 0), from 2 to 5 μs the AND gate outputs a high (<span class="italic">A</span> = 1, <span class="italic">B</span> = 1), and from 5 to 6 μs the AND gate outputs a low (<span class="italic">A</span> = 0, <span class="italic">B</span> = 1). See the leftmost area of <a href="#filepos2671747">Fig. 12.16</a>.</span></div>
<div id="filepos2671747" class="calibre3"><span><img alt="image" src="images/01684.jpg" class="calibre2"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.16</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>Various other specialized waveforms can be generated by using different logic gates and tapping different outputs of the Johnson shift counter. In <a href="#filepos2671747">Fig. 12.16</a>, six other possibilities are shown.</span></div>
<div id="filepos2672308" class="calibre48"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.2.4   Combinational Logic</span></span></span></span></span></div>
<div class="calibre11"><span>Combinational logic involves combining logic gates together to form circuits capable of enacting more useful, complex functions. For example, let’s design the logic used to instruct a janitor-type robot to recharge itself (seek out a power outlet) only when a specific set of conditions is met. The “recharge itself” condition is specified as follows:</span></div>
<div class="calibre187"><span>•  When its battery is low (indicated by a high output signal from a battery-monitor circuit)</span></div>
<div class="calibre27"><span>•  When the workday is over (indicated by a high output signal from a timer circuit)</span></div>
<div class="calibre27"><span>•  When vacuuming is complete (indicated by a high voltage output from a vacuum-completion monitor circuit)</span></div>
<div class="calibre27"><span>•  When waxing is complete (indicated by a high output signal from a wax-completion monitor circuit).</span></div>
<div class="calibre30"><span><a></a>Let’s also assume that the power-outlet-seeking routine circuit is activated when a high is applied to its input.</span></div>
<div class="calibre26"><span>Two simple combinational circuits that perform the desired logic function for the robot are shown in <a href="#filepos2674704">Fig. 12.17</a>. The two circuits use a different number of gates but perform the same function. Now, the question remains, how did we come up with these circuits? In either circuit, it is not hard to predict which gates are needed. You simply exchange the word <span class="italic">and</span> present within the conditional statement with an AND gate within the logic circuit, and exchange the word <span class="italic">or</span> present within the conditional statement with an OR gate within the logic circuit. Common sense takes care of the rest.</span></div>
<div id="filepos2674704" class="calibre3"><span><img alt="image" src="images/01685.jpg" class="calibre2"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.17</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>However, when you begin designing more complex circuits, using intuition to figure out what kind of logic gates to use and how to join them together becomes exceedingly difficult. To make designing combinational circuits easier, a special symbolic language called <span class="italic">Boolean algebra</span> is used, which uses only true and false variables. A Boolean expression for the robot circuit would appear as follows:</span></div>
<div class="calibre19"><span><span class="italic">E</span> = (<span class="italic">B</span> + <span class="italic">T</span>) + <span class="italic">VW</span></span></div>
<div class="calibre30"><span>This expression amounts to saying that if B (battery-check circuit’s output) <span class="italic">or T</span> (timer circuit’s output) is true, or <span class="italic">V and W</span> (vacuum and waxing circuit outputs) are true, then <span class="italic">E</span> (enact power-outlet circuit input) is true.</span></div>
<div class="calibre26"><span><a></a>Note that the word or is replaced by the symbol +, and the word and is simply expressed in a way similar to multiplying two variables together (placing them side by side or using a dot between variables). Also note that the term true in Boolean algebra is expressed as a 1, and false is expressed as a 0. Here, we are assuming positive logic, where true equals high voltage. Using the Boolean expression for the robot circuit, we can come up with some of the following results (the truth table in <a href="#filepos2674704">Fig. 12.17</a> provides all possible results):</span></div>
<table class="calibre99">
<colgroup class="calibre791">
<col class="calibre1481"/>
<col class="calibre1481"/>
</colgroup>
<tr class="calibre100"><td valign="top" class="calibre101"><div class="calibre6"><span><span class="italic">E</span> = (<span class="italic">B</span> + <span class="italic">T</span>) + <span class="italic">VW</span></span></div></td>
<td valign="top" class="calibre101"/>
</tr>
<tr class="calibre100">
<td valign="top" class="calibre101"><div class="calibre11"><span><span class="italic">E</span> = (1 + 1) + (1 · 1) = 1 + 1 = 1</span></div></td>
<td valign="top" class="calibre101"><div class="calibre11"><span>(battery is low, time to sleep, finished with chores = go recharge)</span></div></td>
</tr>
<tr class="calibre100">
<td valign="top" class="calibre101"><div class="calibre11"><span><span class="italic">E</span> = (1 + 0) + (0 · 0) = 1 + 0 = 1</span></div></td>
<td valign="top" class="calibre101"><div class="calibre11"><span>(battery is low = go recharge)</span></div></td>
</tr>
<tr class="calibre100"><td valign="top" class="calibre101"><div class="calibre11"><span><span class="italic">E</span> = (0 + 0) + (1 · 0) = 0 + 0 = 0</span></div></td>
<td valign="top" class="calibre101"><div class="calibre11"><span>(hasn’t finished waxing = don’t recharge yet)</span></div></td>
</tr>
<tr class="calibre100"><td valign="top" class="calibre101"><div class="calibre11"><span><span class="italic">E</span> = (0 + 0) + (1 · 1) = 0 + 1 = 1</span></div></td>
<td valign="top" class="calibre101"><div class="calibre11"><span>(has finished all chores = go recharge)</span></div></td>
</tr>
<tr class="calibre100"><td valign="top" class="calibre101"><div class="calibre11"><span><span class="italic">E</span> = (0 + 0) + (0 · 0) = 0 + 0 = 0</span></div></td>
<td valign="top" class="calibre101"><div class="calibre11"><span>(hasn’t finished vacuuming and waxing = don’t recharge yet)</span></div></td>
</tr>
</table>
<div class="calibre30"><span>The robot example showed you how to express AND and OR functions in Boolean algebraic terms. But what about the negation operations (NOT, NAND, and NOR) and the exclusive operations (XOR and XNOR)? How do you express these in Boolean terms?</span></div>
<div class="calibre187"><span>•  For a NOT condition, place a line over the NOT’ed variable or variables.</span></div>
<div class="calibre27"><span>•  For a NAND expression, place a line over an AND expression.</span></div>
<div class="calibre27"><span>•  For a NOR expression, place a line over an OR expression.</span></div>
<div class="calibre27"><span>•  For exclusive operations, use the symbol ⊕.</span></div>
<div class="calibre30"><span><a href="#filepos2679798">Figure 12.18</a> shows a rundown of all the possible Boolean expressions for the various logic gates.</span></div>
<div id="filepos2679798" class="calibre3"><span><img alt="image" src="images/01686.jpg" class="calibre1482"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.18</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>Like conventional algebra, Boolean algebra has a set of logic identities that can be used to simplify the Boolean expressions and thus make circuits more compact. These identities go by names such as the <span class="italic">commutative law of addition, associate law of addition</span>, and <span class="italic">distributive law</span>. Instead of worrying about what the various identities are called, simply make reference to the list of identities provided on the next page. Most of these identities are self-explanatory, although a few are not so obvious, as you will see in a minute. The various circuits in <a href="#filepos2680812">Fig. 12.19</a> show some of the identities in action.</span></div>
<div id="filepos2680812" class="calibre3"><span><img alt="image" src="images/01687.jpg" class="calibre1483"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.19</span></span></span></div><div class="calibre35"> </div>
<div class="calibre3"><span><a></a><span class="bold">Example</span></span></div>
<div class="calibre11"><span>Let’s find the initial Boolean expression for the circuit in <a href="#filepos2681479">Fig. 12.20</a>, and then use the logic identities to come up with a circuit that requires fewer gates.</span></div>
<div id="filepos2681479" class="calibre3"><span><img alt="image" src="images/01688.jpg" class="calibre1484"/></span></div>
<div class="calibre11"><span class="calibre17"><span class="bold"><span>The circuit shown here is expressed by the following Boolean expression:</span></span></span></div>
<div class="calibre11"><span class="calibre17"><span class="bold"><span><span class="italic">out</span> = (<span class="italic">A</span> + <span class="italic">B</span>)<img alt="image" src="images/01689.jpg" class="calibre1485"/> + <img alt="image" src="images/01689.jpg" class="calibre1485"/> + <span class="italic">BC</span></span></span></span></div>
<div class="calibre11"><span class="calibre17"><span class="bold"><span>This expression can be simplified by using Identity 5:</span></span></span></div>
<div class="calibre11"><span class="calibre17"><span class="bold"><span>(<span class="italic">A</span> + <span class="italic">B</span>)<img alt="image" src="images/01689.jpg" class="calibre1485"/> = <span class="italic">A</span><img alt="image" src="images/01689.jpg" class="calibre1485"/> + <span class="italic">B</span><img alt="image" src="images/01689.jpg" class="calibre1485"/></span></span></span></div>
<div class="calibre11"><span class="calibre17"><span class="bold"><span>This makes:</span></span></span></div>
<div class="calibre11"><span class="calibre17"><span class="bold"><span><span class="italic">out = A<img alt="image" src="images/01689.jpg" class="calibre1485"/> + B<img alt="image" src="images/01689.jpg" class="calibre1485"/> + <img alt="image" src="images/01689.jpg" class="calibre1485"/> = BC</span></span></span></span></div>
<div class="calibre11"><span class="calibre17"><span class="bold"><span>Using Identities 17 (<span class="italic">B<img alt="image" src="images/01689.jpg" class="calibre1485"/></span> = 0) and (<img alt="image" src="images/01689.jpg" class="calibre1485"/> + 0 = <img alt="image" src="images/01689.jpg" class="calibre1485"/>), you get:</span></span></span></div>
<div class="calibre11"><span class="calibre17"><span class="bold"><span><span class="italic">out = A<img alt="image" src="images/01689.jpg" class="calibre1485"/></span> + 0 + <img alt="image" src="images/01689.jpg" class="calibre1485"/> + <span class="italic">BC = A<img alt="image" src="images/01689.jpg" class="calibre1485"/> + BC + <img alt="image" src="images/01689.jpg" class="calibre1485"/></span></span></span></span></div>
<div class="calibre11"><span class="calibre17"><span class="bold"><span>Factoring a <img alt="image" src="images/01689.jpg" class="calibre1485"/> from the preceding term gives:</span></span></span></div>
<div class="calibre11"><span class="calibre17"><span class="bold"><span><span class="italic">out</span> = <img alt="image" src="images/01689.jpg" class="calibre1485"/>(<span class="italic">A</span> + 1) + <span class="italic">BC</span></span></span></span></div>
<div class="calibre11"><span class="calibre17"><span class="bold"><span>Using Identity 10, you get:</span></span></span></div>
<div class="calibre11"><span class="calibre17"><span class="bold"><span>out = <img alt="image" src="images/01689.jpg" class="calibre1485"/>(1) + <span class="italic">BC = <img alt="image" src="images/01689.jpg" class="calibre1485"/> + BC</span></span></span></span></div>
<div class="calibre11"><span class="calibre17"><span class="bold"><span>Finally, using Identity 21, you get the simplified expression:</span></span></span></div>
<div class="calibre11"><span class="calibre17"><span class="bold"><span><span class="italic">out = <img alt="image" src="images/01689.jpg" class="calibre1485"/> + C</span></span></span></span></div>
<div class="calibre26"><span class="calibre17"><span class="bold"><span>Notice that <span class="italic">A</span> is now missing. This means that the logic input at <span class="italic">A</span> has no effect on the output and therefore can be omitted. From the reduction, you get the simplified circuit in the bottom part of the figure.</span></span></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.20</span></span></span></div><div class="calibre35"> </div>
<div class="calibre3"><span><a></a><span class="bold">Dealing with Exclusive Gates (Identities 22 and 23)</span></span></div>
<div class="calibre11"><span>Now let’s take a look at a couple of not-so-obvious logic identities: those that involve the XOR (Identity 22) and XNOR (Identity 23) gates. The leftmost section in <a href="#filepos2686215">Fig. 12.21</a> shows equivalent circuits for the XOR gate. In the lower two equivalent circuits, Identity 22 is proved by Boolean reduction. Equivalent circuits for the XNOR gate are shown in the rightmost section of the figure. To prove Identity 23, you can simply invert Identity 22.</span></div>
<div id="filepos2686215" class="calibre3"><span><img alt="image" src="images/01690.jpg" class="calibre971"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.21</span></span></span></div><div class="calibre35"> </div>
<div class="calibre3"><span><span class="bold">De Morgan’s Theorem (Identities 18 and 19)</span></span></div>
<div class="calibre11"><span>To simplify circuits containing NANDs and NORs, you can use an incredibly useful theorem known as <span class="italic">De Morgan’s theorem</span>. This theorem allows you to convert an expression having an inversion bar over two or more variables into an expression having inversion bars over single variables only. De Morgan’s theorem (Identities 18 and 19) is as follows:</span></div>
<div class="calibre19"><span><img alt="image" src="images/01691.jpg" class="calibre1486"/></span></div>
<div class="calibre30"><span>The easiest way to prove that these identities are correct is to use <a href="#filepos2687789">Fig. 12.22</a>, noting that the truth tables for the equivalent circuits are the same. Note the inversion bubbles present on the inputs of the corresponding leftmost gates. The inversion bubbles mean that before inputs <span class="italic">A</span> and <span class="italic">B</span> are applied to the base gate, they are inverted (negated). In other words, the bubbles are simplified expressions for NOT gates.</span></div>
<div id="filepos2687789" class="calibre3"><span><img alt="image" src="images/01692.jpg" class="calibre886"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.22</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span><a></a>Why do you use the inverted-input OR gate symbol instead of a NAND gate symbol? Or why would you use the inverted-input AND gate symbol instead of a NOR gate symbol? This is left up to the designer to choose whatever symbol seems most logical to use. For example, when designing a circuit, it may be easier to think about ORing or ANDing inverted inputs than to think about NANDing or NORing inputs. Similarly, it may be easier to create truth tables or work with Boolean expressions using the inverted-input gate. It is typically easier to create truth tables and Boolean expressions that do not have variables joined under a common inversion bar. Of course, when it comes time to construct the actual working circuit, you probably will want to convert to the NAND and NOR gates because they do not require additional NOT gates at their inputs.</span></div>
<div class="calibre3"><span><span class="bold">Bubble Pushing</span></span></div>
<div class="calibre11"><span>A shortcut method for forming equivalent logic circuits, based on De Morgan’s theorem, is to use what’s called <span class="italic">bubble pushing</span>.</span></div>
<div class="calibre26"><span>Bubble pushing involves the following tricks:</span></div>
<div class="calibre187"><span>•  Change an AND gate to an OR gate or change an OR gate to an AND gate.</span></div>
<div class="calibre27"><span>•  Add inversion bubbles to the inputs and outputs where there were none, while removing the original bubbles.</span></div>
<div class="calibre30"><span>That’s it. You can prove to yourself that this works by examining the corresponding truth tables for the original gate and the bubble-pushed gate, or you can work out the Boolean expressions using De Morgan’s theorem. <a href="#filepos2690288">Figure 12.23</a> shows examples of bubble pushing.</span></div>
<div id="filepos2690288" class="calibre3"><span><img alt="image" src="images/01693.jpg" class="calibre1487"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.23</span></span></span></div><div class="calibre35"> </div>
<div class="calibre3"><span><span class="bold">Universal Capability of NAND and NOR Gates</span></span></div>
<div class="calibre11"><span><a></a>NAND and NOR gates are referred to as <span class="italic">universal gates</span> because each alone can be combined together with itself to form all other possible logic gates. The ability to create any logic gate from NAND or NOR gates is obviously a handy feature. For example, if you do not have an XOR IC handy, you can use a single multigate NAND gate (such as 74HC00) instead. <a href="#filepos2691301">Figure 12.24</a> shows how to wire NAND or NOR gates together to create equivalent circuits of the various logic gates.</span></div>
<div id="filepos2691301" class="calibre3"><span><img alt="image" src="images/01694.jpg" class="calibre1488"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.24</span></span></span></div><div class="calibre35"> </div>
<div class="calibre3"><span><span class="bold">AND-OR-INVERTER Gates</span></span></div>
<div class="calibre11"><span>When a Boolean expression is reduced, the equation that is left over typically will be of one of the following two forms: <span class="italic">product of sums</span> (POS) or <span class="italic">sum of products</span> (SOP). A POS expression appears as two or more OR'ed variables AND'ed together with two or more additional OR'ed variables. An SOP expression appears as two or more AND'ed variables OR'ed together with additional AND'ed variables. <a href="#filepos2692487">Figure 12.25</a> shows two circuits that provide the same logic function (they are equivalent), but the circuit to the left is designed to yield a POS expression, while the circuit to the right is designed to yield a SOP expression.</span></div>
<div id="filepos2692487" class="calibre3"><span><img alt="image" src="images/01695.jpg" class="calibre1489"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.25</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span><a></a>Which circuit is best for design: the one that implements the POS expression or the one that implements the SOP expression? The POS design shown here would appear to be the better choice because it requires fewer gates. However, the SOP design is nice because it is easy to work with the Boolean expression. For example, which Boolean expression in <a href="#filepos2692487">Fig. 12.25</a> (POS or SOP) would you rather use to create a truth table? The SOP expression seems the obvious choice.</span></div>
<div class="calibre26"><span>A more down-to-earth reason for using an SOP design has to do with the fact that special ICs called AND-OR-INVERTER (AOI) gates are designed to handle SOP expressions. For example, the 74LS54 AOI IC shown in <a href="#filepos2694144">Fig. 12.26</a> creates an inverted SOP expression at its output, via two two-input AND gates and two three-input AND gates NOR'ed together. A NOT gate can be attached to the output to get rid of the inversion bar, if desired. If specific inputs are not used, they should be held high, as shown in the example circuit in <a href="#filepos2694144">Fig. 12.26</a>. AOI ICs come in many different configurations—check out the catalogs to see what’s available.</span></div>
<div id="filepos2694144" class="calibre3"><span><img alt="image" src="images/01696.jpg" class="calibre64"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.26</span></span></span></div><div class="calibre35"> </div>
<div id="filepos2694420" class="calibre3"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.2.5   Keeping Circuits Simple (Karnaugh Maps</span>)</span></span></span></span></div>
<div class="calibre11"><span><a></a>We have just covered how using the logic identities can simplify a Boolean expression. This is important because it reduces the number of gates needed to construct the logic circuit. However, as I am sure you will agree, having to work out Boolean problems in longhand is not easy. It takes time and ingenuity. A simple way to avoid the unpleasant task of using your ingenuity is to get a computer program that accepts a truth table or Boolean expression, and then provides you with the simplest expression, and perhaps even the circuit schematic.</span></div>
<div class="calibre26"><span>However, let’s assume that you do not have such a program to help you out. Are you stuck with the Boolean longhand approach? No. You can use a technique referred to as <span class="italic">Karnaugh mapping</span>. With this technique, you take a given truth table (or Boolean expression that can be converted into a truth table), convert it into a Karnaugh map, apply some simple graphic rules, and come up with the simplest (most of the time) possible Boolean expression for your final circuit. Karnaugh mapping works best for circuits with three to four inputs—below this, things usually do not require much thought anyway; beyond four inputs, things get quite tricky.</span></div>
<div class="calibre26"><span>Here’s a basic outline showing how to apply Karnaugh mapping to a three-input system:</span></div>
<div class="calibre595"><span>1. Select a desired truth table. Let’s choose the one shown in <a href="#filepos2696597">Fig. 12.27</a>. (If you have only a Boolean expression, transform it into an SOP expression and use the SOP expression to create the truth table; refer to <a href="#filepos2694144">Fig. 12.26</a> to figure out how this is done.)</span></div>
<div id="filepos2696597" class="calibre3"><span><img alt="image" src="images/01697.jpg" class="calibre1284"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.27</span></span></span></div><div class="calibre35"> </div>
<div class="calibre595"><span>2. Translate the truth table into a Karnaugh map. A Karnaugh map is similar to a truth table but has its variables represented along two axes. Translating the truth table into a Karnaugh map reduces the number of 1s and 0s needed to present the information. <a href="#filepos2696597">Figure 12.27</a> shows how the translation is carried out.</span></div>
<div class="calibre595"><span><a></a>3.  After you create the Karnaugh map, proceed to encircle adjacent cells of 1s into groups of 2, 4, or 8. The more groups you can encircle, the simpler the final equation will be. In other words, take all possible loops.</span></div>
<div class="calibre595"><span>4. Identify the variables that remain constant within each loop, and write out an SOP equation by OR'ing these variables together. Here, <span class="italic">constant</span> means that a variable and its inverse are not present together within the loop. For example, the top horizontal loop in <a href="#filepos2696597">Fig. 12.27</a> yields <span class="italic"><img alt="image" src="images/01698.jpg" class="calibre1490"/></span> (the first term in the SOP expression), since <span class="italic"><img alt="image" src="images/01679.jpg" class="calibre1491"/>’s</span> and <span class="italic"><img alt="image" src="images/01689.jpg" class="calibre1485"/>’s</span> inverses (<span class="italic">A</span> and <span class="italic">B</span>) are not present. However, the <span class="italic">C</span> variable is omitted from this term because <span class="italic">C</span> and <img alt="image" src="images/01681.jpg" class="calibre1492"/> are both present.</span></div>
<div class="calibre595"><span>5. The SOP expression you end up with is the simplest possible expression. With it, you can create your logic circuit. You may need to apply some bubble pushing to make the final circuit practical, as shown in <a href="#filepos2698873">Fig. 12.28</a>.</span></div>
<div id="filepos2698873" class="calibre3"><span><img alt="image" src="images/01699.jpg" class="calibre1493"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.28</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>To apply Karnaugh mapping to four-input circuits, you apply the same basic steps used in the three-input scheme. However, now you must use a 4 × 4 Karnaugh map to hold all the necessary information. <a href="#filepos2698873">Figure 12.28</a> shows an example of how a four-input truth table (or unsimplified four-variable SOP expression) can be mapped and converted into a simplified SOP expression that can be used to create the final logic circuit.</span></div>
<div class="calibre26"><span><a></a><a href="#filepos2700133">Figure 12.29</a> shows an example that uses an AOI IC to implement the final SOP expression after mapping. I’ve thrown in variables other than the traditional A, B, C, and <span class="italic">D</span> just to let you know you are not limited to them alone. The choice of variables is up to you and usually depends on the application.</span></div>
<div id="filepos2700133" class="calibre3"><span><img alt="image" src="images/01700.jpg" class="calibre193"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.29</span></span></span></div><div class="calibre35"> </div>
<div class="calibre3"><span><span class="bold">Other Looping Configurations</span></span></div>
<div class="calibre11"><span><a href="#filepos2700743">Figure 12.30</a> shows examples of other looping arrangements used with 4 × 4 Karnaugh maps.</span></div>
<div id="filepos2700743" class="calibre3"><span><img alt="image" src="images/01701.jpg" class="calibre1494"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.30</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>There are also useful online resources for exploring truth tables and minimizing logical expressions, such as these:</span></div>
<div class="calibre26"><span><a href="http://turner.faculty.swau.edu/mathematics/materialslibrary/truth/">http://turner.faculty.swau.edu/mathematics/materialslibrary/truth/</a></span></div>
<div class="calibre26"><span><a href="http://courseware.ee.calpoly.edu/~rsandige/KarnaughExplorer.html">http://courseware.ee.calpoly.edu/~rsandige/KarnaughExplorer.html</a></span></div>
<div id="filepos2701695" class="calibre3"><span class="calibre7"><span><span class="bold">12.3   Combinational Devices</span></span></span></div>
<div class="calibre11"><span><img alt="image" src="images/00007.jpg" class="calibre36"/></span></div>
<div class="calibre11"><span>Now that you know a little something about how to use logic gates to enact functions represented within truth tables and Boolean expressions, it is time to take a look at some common functions that are used in the real world of digital electronics. As you will see, these functions are usually carried out by an IC that contains all the necessary logic.</span></div>
<div class="calibre26"><span>As with almost everything discussed in this chapter, before using these ideas, you need to ask yourself if using a microcontroller would be more appropriate. However, many of the devices described here can be used with a microcontroller, especially when it comes to decoders. They can be a useful and low-cost solution for tasks such as driving more LEDs than there are pins on the microcontroller that you are using.</span></div>
<div class="calibre26"><span>A word on IC part numbers before we begin. As with the logic gate ICs, the combinational ICs that follow will be of either the 4000 or 7400 series. It is important to note that an original TTL IC, like the 74138, is essentially the same device (usually with the same pinouts and function, but not always) as its newer counterparts, such as the 74F138, 74HC128 (CMOS), and 74LS138. The practical difference resides in the overall performance of the device (speed, power dissipation, voltage level rating, and so on). I will get into these gory details in a bit.</span></div>
<div class="calibre3"><span><img alt="image" src="images/01702.jpg" class="calibre1495"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.31</span></span></span></div><div class="calibre35"> </div>
<div id="filepos2703885" class="calibre3"><span class="bold"><span class="italic"><span><a></a><span class="bold"><span class="italic">12.3.1   Multiplexers (Data Selectors) and Bilateral Switches</span></span></span></span></span></div>
<div class="calibre11"><span>Multiplexers or data selectors act as digitally controlled switches. The term <span class="italic">data selector</span> appears to be the accepted term when the device is designed to act like an SPDT switch, while the term <span class="italic">multiplexer</span> is used when the throw count of the switch exceeds two, such as an SP8T. I will stick with this convention (although others may not).</span></div>
<div class="calibre26"><span>A simple 1-of-2 data selector built from logic gates is shown in <a href="#filepos2705072">Fig. 12.32</a>. The data select input of this circuit acts to control which input (<span class="italic">A</span> or <span class="italic">B</span>) gets passed to the output: When data select is low, input <span class="italic">A</span> passes while <span class="italic">B</span> is blocked. When data select is high, input <span class="italic">B</span> is passed while <span class="italic">A</span> is blocked. To understand how this circuit works, think of the AND gates as enable gates.</span></div>
<div id="filepos2705072" class="calibre3"><span><img alt="image" src="images/01703.jpg" class="calibre121"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.32</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>There are a number of different types of data selectors that come in IC form. For example, the 74LS157 quad 1-of-2 data selector IC, shown in <a href="#filepos2705072">Fig. 12.32</a>, acts like an electrically controlled quad SPDT switch (or if you like, a 4PDT switch). When its select input is set high (1), inputs <span class="italic">A</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">1</span></small></sub>, <span class="italic">A</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">2</span></small></sub>, <span class="italic">A</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">3</span></small></sub>, and <span class="italic">A</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">4</span></small></sub> are allowed to pass to outputs <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">1</span></small></sub>, <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">2</span></small></sub>, <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">3</span></small></sub>, and <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">4</span></small></sub>. When its select input is low (0), inputs <span class="italic">B</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">1</span></small></sub>, <span class="italic">B</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">2</span></small></sub>, <span class="italic">B</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">3</span></small></sub>, and <span class="italic">B</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">4</span></small></sub> are allowed to pass to outputs <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">1</span></small></sub>, <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">2</span></small></sub>, <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">3</span></small></sub>, and <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">4</span></small></sub>. Either of these two conditions, however, ultimately depends on the state of the enable input.</span></div>
<div class="calibre26"><span>When the enable input is low, all data-input signals are allowed to pass to the output; however, if the enable is high, the signals are not allowed to pass. This type of enable control is referred to as <span class="italic">active-low</span> enable, since the active function (passing the data to the output) occurs only with a low-level input voltage. The active-low input is denoted with a bubble (inversion bubble), and the outer label of the active-low input is represented with a line over it. Sometimes people omit the bubble and place a bar over the inner label. Both conventions are used commonly.</span></div>
<div id="filepos2707596" class="calibre3"><span><img alt="image" src="images/01704.jpg" class="calibre1273"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.33</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span><a href="#filepos2707596">Figure 12.33</a> shows a 4-line-to-1-line multiplexer built with logic gates. This circuit resembles the 2-of-1 data selector shown in <a href="#filepos2705072">Fig. 12.32</a> but requires an additional select input to provide four address combinations.</span></div>
<div class="calibre26"><span><a></a>In terms of ICs, there are multiplexers of various input line capacities. For example, the 74151 8-line-to-1-line multiplexer uses three select inputs (<span class="italic">S</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">0</span></small></sub>, <span class="italic">S</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">1</span></small></sub>, <span class="italic">S</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">2</span></small></sub>) to choose among one of eight possible data inputs (<span class="italic">I</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">0</span></small></sub> to <span class="italic">I</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">7</span></small></sub>) to be funneled to the output. Note that this device actually has two outputs: one true (pin 5) and one inverted (pin 6). The active-low enable forces the true output low when set high, regardless of the inputs.</span></div>
<div class="calibre26"><span>To create a larger multiplexer, you combine two smaller multiplexers together. For example, <a href="#filepos2709531">Fig. 12.34</a> shows two 8-line-to-1-line 74HC151s combined to create a 16-line-to-1-line multiplexer. Another alternative is to use a 16-line-to-1-line multiplexer IC like the 74HC150 shown in the figure. Check the catalogs to see what other kinds of multiplexers are available.</span></div>
<div id="filepos2709531" class="calibre3"><span><img alt="image" src="images/01705.jpg" class="calibre103"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.34</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>Finally, let’s take a look at a very useful device called a <span class="italic">bilateral switch</span>. An example bilateral switch IC is the 4066, shown to the far right in <a href="#filepos2705072">Fig. 12.32</a>. Unlike the multiplexer, this device merely acts as a digitally controlled quad SPST switch or quad transmission gate. Using a digital control input, you select which switches are on and which switches are off. To turn on a given switch, apply a high level to the corresponding switch select input; otherwise, keep the select input low.</span></div>
<div class="calibre26"><span>In <a href="CR%21QKYKJ7KY3158K36EJE0G9AYNF2ZW_split_018.html#filepos2942250">Section 12.10</a>, we will look at analog switches and multiplexers. These devices use digital select inputs to control analog signals. Analog switches and multiplexers become important when you start linking the digital world to the analog world.</span></div>
<div id="filepos2710796" class="calibre48"><span class="bold"><span class="italic"><span><a></a><span class="bold"><span class="italic">12.3.2   Demultiplexers (Data Distributors) and Decoders</span></span></span></span></span></div>
<div class="calibre11"><span>A demultiplexer (or data distributor) is the opposite of a multiplexer. It takes a single data input and routes it to one of several possible outputs. A simple four-line demultiplexer built from logic gates is shown on the left side of <a href="#filepos2711675">Fig. 12.35</a>. To select the output (<span class="italic">A, B, C</span>, or <span class="italic">D</span>) to which you want to send the input signal (applied at <span class="italic">E</span>), you apply logic levels to the data select inputs (<span class="italic">S</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">0</span></small></sub>, <span class="italic">S</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">1</span></small></sub>), as shown in the truth table.</span></div>
<div id="filepos2711675" class="calibre3"><span><img alt="image" src="images/01706.jpg" class="calibre1496"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.35</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>Notice that the unselected outputs assume a high level, while the selected output varies with the input signal. An IC that contains two functionally separate four-line demultiplexers is the 74HC139, shown on the right side of <a href="#filepos2711675">Fig. 12.35</a>. If you need more outputs, check out the 75<span class="italic">xx</span>154 16-line demultiplexer. This IC uses four data select inputs to choose from 1 of 16 possible outputs. Check out the catalogs to see what other demultiplexers exist.</span></div>
<div class="calibre26"><span>A decoder is somewhat like a demultiplexer, but it does not route input data to a specific output via data select inputs. Instead, it simply uses the data select inputs to choose which output (or outputs) among many are to be made high or low. The number of address inputs, the number of outputs, and the active state of the selected output vary from decoder to decoder. The variance is based on what the decoder is designed to do. For example, the 74LS138 1-of-8 decoder shown in <a href="#filepos2713345">Fig. 12.36</a> uses a 3-bit address input to select which of eight outputs will be made low; all other outputs are held high. Like the demultiplexer in <a href="#filepos2711675">Fig. 12.35</a>, this decoder has active-low outputs.</span></div>
<div id="filepos2713345" class="calibre3"><span><img alt="image" src="images/01707.jpg" class="calibre181"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.36</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>Now what exactly does it mean to say an output is an active-low output? It simply means that when an active-low output is selected, it is forced to a low logic state; otherwise, it is held high. Active-high outputs behave in the opposite manner. An active-low output is usually indicated with a bubble, although sometimes it is indicated with a barred variable within the IC logic symbol—no bubble included. Active-high outputs have no bubbles. Both active-low and active-high outputs are equally common among ICs.</span></div>
<div class="calibre26"><span><a></a>By placing a load (for example, a warning LED) between <span class="italic">+V<sub class="calibre37"><small class="calibre28"><span class="calibre17">CC</span></small></sub></span> and an active-low output, you can sink current through the load and into the active-low output when the output is selected. By placing a load between an active-high output and ground, you can source current from the active-high output and sink it through the load when the output is selected. The limits to how much current an IC can source or sink will be discussed in <a href="#filepos2748176">Section 12.4</a>, and various schemes used to drive analog loads will be presented in <a href="CR%21QKYKJ7KY3158K36EJE0G9AYNF2ZW_split_018.html#filepos2942250">Section 12.10</a>.</span></div>
<div class="calibre26"><span>Now let’s get back to the 74LS138 decoder and discuss the remaining enable inputs (<img alt="image" src="images/01708.jpg" class="calibre1497"/><sub class="calibre37"><small class="calibre28"><span class="calibre17">0</span></small></sub>,<img alt="image" src="images/01708.jpg" class="calibre1497"/><sub class="calibre37"><small class="calibre28"><span class="calibre17">1</span></small></sub>,E<sub class="calibre37"><small class="calibre28"><span class="calibre17">2</span></small></sub>). For the 74LS138 to “decode,” you must make the active-low inputs <img alt="image" src="images/01708.jpg" class="calibre1497"/><sub class="calibre37"><small class="calibre28"><span class="calibre17">0</span></small></sub> and <img alt="image" src="images/01708.jpg" class="calibre1497"/><sub class="calibre37"><small class="calibre28"><span class="calibre17">1</span></small></sub> low, while making the active-high input <span class="italic">E</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">2</span></small></sub> high. If any other set of enable inputs is applied, the decoder is disabled, making all active-low outputs high regardless of the selected inputs.</span></div>
<div class="calibre26"><span>Other common decoders include the 7442 BCD-to-DEC (decimal) decoder, the 74154 1-of-16 (hex) decoder, and the 7447 BCD-to-seven-segment decoder shown in <a href="#filepos2716569">Figure 12.37</a>. Like the preceding decoder, these devices also have active-low outputs. The 7442 uses a binary-coded decimal input to select 1 of 10 (0 through 9) possible outputs. The 74154 uses a 4-bit binary input to address 1 of 16 (or 0 of 15) outputs, making that output low (all others high), provided the enables are both set low.</span></div>
<div id="filepos2716569" class="calibre3"><span><img alt="image" src="images/01709.jpg" class="calibre281"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.37</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span><a></a>Now the 7447 is a bit different from the other decoders. With this device, more than one output can be driven low at a time. This is important because it allows the 7447 to drive a seven-segment LED display; to create different numbers requires driving more than one LED segment at a time. For example, in <a href="#filepos2717719">Fig. 12.38</a>, when the BCD number for 5 (0101) is applied to the 7447’s inputs, all outputs except <span class="italic"><img alt="image" src="images/01710.jpg" class="calibre1498"/></span>and <span class="italic"><img alt="image" src="images/01711.jpg" class="calibre1499"/></span> go low. This causes LED segments <span class="italic">a, c, d, f</span>, and <span class="italic">g</span> to light up—the 7447 sinks current through these LED segments, as indicated by the internal wiring of the display and the truth table.</span></div>
<div id="filepos2717719" class="calibre3"><span><img alt="image" src="images/01712.jpg" class="calibre169"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.38</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>The 7447 also comes with a lamp test active-low input (<span class="italic"><img alt="image" src="images/01713.jpg" class="calibre1500"/></span>) that can be used to drive all LED segments at once to see if any of the segments are faulty. The ripple blanking input (<img alt="image" src="images/01714.jpg" class="calibre1501"/>) and ripple blanking output (<img alt="image" src="images/01715.jpg" class="calibre1502"/>) can be used in multistage display applications to suppress a leading-edge and/or trailing-edge zero in a multidigit decimal. For example, using the ripple blanking inputs and outputs, it is possible to take an eight-digit expression like 0056.020 and display 56.02, suppressing the two leading zeros and the one trailing zero. Leading-edge zero suppression is obtained by connecting the ripple blanking output of a decoder to the ripple blanking input of the next lower-stage device. The most significant decoder stage should have its ripple blanking input grounded. A similar procedure is used to provide automatic suppression of trailing zeros in the fractional part of the decimal.</span></div>
<div id="filepos2719159" class="calibre48"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.3.3   Encoders and Code Converters</span></span></span></span></span></div>
<div class="calibre11"><span>Encoders are the opposite of decoders. They are used to generate a coded output from a single active numeric input. To illustrate this in a simple manner, let’s take a look at the simple decimal-to-BCD encoder circuit shown in <a href="#filepos2719693">Fig. 12.39</a>.</span></div>
<div id="filepos2719693" class="calibre3"><span><img alt="image" src="images/01716.jpg" class="calibre1482"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.39</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>In this circuit, normally all lines are held high by the pullup resistors connected to +5 V. To generate a BCD output that is equivalent to a single selected decimal input, the switch corresponding to that decimal is closed. (The switch acts as an active-low input.) The truth table in <a href="#filepos2719693">Fig. 12.39</a> explains the rest.</span></div>
<div class="calibre26"><span><a></a><a href="#filepos2721343">Figure 12.40</a> shows a 74LS147 decimal-to-BCD (ten-line-to-four-line) priority encoder IC. The 74LS147 provides the same basic function as the circuit shown in <a href="#filepos2719693">Fig. 12.39</a>, but it has active-low outputs. This means that instead of getting an LLHH output when 3 is selected, as in the previous encoder, you get HHLL. The two outputs represent the same thing (3); one is expressed in positive true logic, and the other (the 74LS147) is expressed in negative true logic. If you do not like negative true logic, you can slap inverters on the outputs of the 74LS147 to get positive true logic. The choice to use positive or negative true logic really depends on what you are planning to drive. For example, negative true logic is useful when the device that you wish to drive uses active-low inputs.</span></div>
<div id="filepos2721343" class="calibre3"><span><img alt="image" src="images/01717.jpg" class="calibre1503"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.40</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span><a></a>Another important difference between the two encoders is the priority that is used with the 74LS147 and not used with the encoder in <a href="#filepos2719693">Fig. 12.39</a>. The term <span class="italic">priority</span> is applied to the 74LS147 because this encoder is designed so that if two or more inputs are selected at the same time, it will select only the larger-order digit. For example, if 3, 5, and 8 are selected at the same time, only the 8 (negative true BCD LHHH or 0111) will be output. The truth table in <a href="#filepos2721343">Fig. 12.40</a> demonstrates this; look at the “don’t care” or “X” entries. With the nonpriority encoder, if two or more inputs are applied at the same time, the output will be unpredictable.</span></div>
<div class="calibre26"><span>The circuit shown in <a href="#filepos2722984">Fig. 12.41</a> provides a simple illustration of how an encoder and a decoder can be used together to drive an LED display via a 0 through 9 keypad. The 74LS147 encodes a keypad’s input into BCD (negative logic). A set of inverters then converts the negative true BCD into positive true BCD. The transformed BCD is then fed into a 7447 seven-segment LED display decoder/driver IC.</span></div>
<div id="filepos2722984" class="calibre3"><span><img alt="image" src="images/01718.jpg" class="calibre1275"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.41</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span><a href="#filepos2723686">Figure 12.42</a> shows a 74148 octal-to-binary priory encoder IC. It is used to transform a specified single octal input into a binary 3-bit output code. As with the 74LS147, the 74148 comes with a priority feature, so if two or more inputs are selected at the same time, only the higher-order number is selected.</span></div>
<div id="filepos2723686" class="calibre3"><span><img alt="image" src="images/01719.jpg" class="calibre228"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.42</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span><a></a>A high applied to the input enable (<img alt="image" src="images/01720.jpg" class="calibre1504"/>) forces all outputs to their inactive (high) state and allows new data to settle without producing erroneous information at the outputs. A group signal output (<img alt="image" src="images/01721.jpg" class="calibre1505"/>) and an enable output (<img alt="image" src="images/01722.jpg" class="calibre1506"/>) are also provided to allow for system expansion. The <img alt="image" src="images/01721.jpg" class="calibre1505"/> output is active level low when any input is low (active). The <img alt="image" src="images/01722.jpg" class="calibre1506"/> output is low (active) when all inputs are high. Using the output enable along with the input enable allows priority coding of <span class="italic">N</span> input signals. Both <img alt="image" src="images/01722.jpg" class="calibre1506"/> and <img alt="image" src="images/01721.jpg" class="calibre1505"/> are active high when the input enable is high (device disabled).</span></div>
<div class="calibre26"><span><a href="#filepos2725986">Figure 12.43</a> shows a 74184 BCD-to-binary converter (encoder) IC. This device has eight active-high outputs (<span class="italic">Y</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">1</span></small></sub> – <span class="italic">Y</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">8</span></small></sub>). Outputs <span class="italic">Y</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">1</span></small></sub> to <span class="italic">Y</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">5</span></small></sub> are outputs for regular BCD-to-binary conversion, while outputs <span class="italic">Y</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">6</span></small></sub> to <span class="italic">Y</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">8</span></small></sub> are used for a special BDC code called <span class="italic">nine’s complement</span> and <span class="italic">ten’s complement</span>. The active-high BCD code is applied to inputs <span class="italic">A</span> through <span class="italic">E</span>. The <span class="italic"><img alt="image" src="images/01723.jpg" class="calibre1507"/></span> input is an active-low enable input.</span></div>
<div id="filepos2725986" class="calibre3"><span><img alt="image" src="images/01724.jpg" class="calibre304"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.43</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>A sample 6-bit BCD-to-binary converter and a sample 8-bit BCD-to-binary converter that use the 74184 are shown to the right in <a href="#filepos2725986">Fig. 12.43</a>. In the 6-bit circuit, since the LSB of the BCD input is always equal to the LSB of the binary output, the connection is made straight from input to output. The other BCD bits are applied directly to inputs <span class="italic">A</span> through <span class="italic">E</span>. The binary weighing factors for each input are <span class="italic">A</span> = 2, <span class="italic">B</span> = 4, <span class="italic">C</span> = 8, <span class="italic">D</span> = 10, and <span class="italic">E</span> = 20. Because only 2 bits are available for the MSD BCD input, the largest BCD digit in that position is 3 (binary 11). To get a complete 8-bit BCD converter, you connect two 74184s together, as shown to the far right in <a href="#filepos2725986">Fig. 12.43</a>.</span></div>
<div class="calibre26"><span><a href="#filepos2727433">Figure 12.44</a> shows a 74185 binary-to-BCD converter (encoder). It is essentially the same as the 74184, but in reverse. The figure shows 6-bit and 8-bit binary-to-BCD converter arrangements.</span></div>
<div id="filepos2727433" class="calibre3"><span><img alt="image" src="images/01725.jpg" class="calibre1508"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.44</span></span></span></div><div class="calibre35"> </div>
<div id="filepos2727709" class="calibre3"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.3.4   Binary Adders</span></span></span></span></span></div>
<div class="calibre11"><span>If you find yourself needing to do arithmetic in logic, then that is a pretty sure sign that you need to use a microcontroller. However, that microcontroller will contain exactly the sort of logic that we describe here in its arithmetic logic unit (ALU), so it is instructive to see how it works under the hood.</span></div>
<div class="calibre26"><span><a></a>With a few logic gates, you can create a circuit that adds binary numbers. The mechanics of adding binary numbers is basically the same as that of adding decimal numbers. When the first digit of a two-digit number is added, a 1 is carried and added to the next row whenever the count exceeds binary 2 (for example., 1 + 1 = 10, or = 0 carry a 1). For numbers with more digits, you have multiple carry bits.</span></div>
<div class="calibre26"><span>To demonstrate how you can use logic gates to perform basic addition, start out by considering the half-adder circuits in <a href="#filepos2729414">Fig. 12.45</a>. Both half-adders shown are equivalent; one simply uses XOR/AND logic, while the other uses NOR/AND logic. The half-adder adds two single-bit numbers <span class="italic">A</span> and <span class="italic">B</span> and produces a 2-bit number. The LSB is represented as Σ<sub class="calibre37"><small class="calibre28"><span class="calibre17">0</span></small></sub>, and the MSB, or carry bit, is represented as <span class="italic">C</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">out</span></small></sub>.</span></div>
<div id="filepos2729414" class="calibre3"><span><img alt="image" src="images/01726.jpg" class="calibre1509"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.45</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span><a></a>The most complicated operation the half-adder can do is 1 + 1. To perform addition on a two-digit number, you must attach a full-adder circuit (shown in <a href="#filepos2729414">Fig. 12.45</a>) to the output of the half-adder. The full-adder has three inputs: two to input the second digits of the two binary numbers (<span class="italic">A</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">1</span></small></sub>, <span class="italic">B</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">1</span></small></sub>), and another that accepts the carry bit from the half-adder (the circuit that added the first digits, <span class="italic">A</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">0</span></small></sub> and <span class="italic">B</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">0</span></small></sub>, of the two numbers). The two outputs of the full-adder will provide the 2d-place digit sum Σ<sub class="calibre37"><small class="calibre28"><span class="calibre17">1</span></small></sub> and another carry bit that acts as the third-place digit of the final sum. Now, you can keep adding more full-adders to the half-adder/full-adder combination to add larger numbers, linking the carry bit output of the first full-adder to the next full-adder, and so forth. To illustrate this point, a 4-bit adder is shown in <a href="#filepos2729414">Fig. 12.45</a>.</span></div>
<div class="calibre26"><span>A number of 4-bit full-adder ICs are available, such as the 74LS283 and 4008. These devices will add two 4-bit binary numbers and provide an additional input carry bit, as well as an output carry bit, so you can stack them together to get adders that are 8-bit, 12-bit, 16-bit, and so on. For example, <a href="#filepos2731454">Fig. 12.46</a> shows an 8-bit adder made by cascading two 74LS283 4-bit adders.</span></div>
<div id="filepos2731454" class="calibre3"><span><img alt="image" src="images/01727.jpg" class="calibre1510"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.46</span></span></span></div><div class="calibre35"> </div>
<div id="filepos2731730" class="calibre3"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.3.5   Binary Adder/Subtractor</span></span></span></span></span></div>
<div class="calibre11"><span><a href="#filepos2732517">Figure 12.47</a> shows how two 74LS283 4-bit adders can be combined with an XOR array to yield an 8-bit 2’s complement adder/subtractor. The first number <span class="italic">X</span> is applied to the <span class="italic">X</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">0</span></small></sub> through <span class="italic">X</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">7</span></small></sub> inputs, while the second number <span class="italic">Y</span> is applied to the <span class="italic">Y</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">0</span></small></sub> through <span class="italic">Y</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">7</span></small></sub> inputs.</span></div>
<div id="filepos2732517" class="calibre3"><span><img alt="image" src="images/01728.jpg" class="calibre1449"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.47</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span><a></a>To add <span class="italic">X</span> and <span class="italic">Y</span>, the add/subtract switch is thrown to the add position, making one input of all XOR gates low. This has the effect of making the XOR gates appear transparent, allowing <span class="italic">Y</span> values to pass to the 74LS283s’ <span class="italic">B</span> inputs (<span class="italic">X</span> values are passed to the <span class="italic">A</span> inputs). The 8-bit adder then adds the numbers and presents the result to the Σ outputs.</span></div>
<div class="calibre26"><span>To subtract <span class="italic">Y</span> from <span class="italic">X</span>, you must first convert <span class="italic">Y</span> into 1’s complement form; then you must add 1 to get <span class="italic">Y</span> into 2’s complement form. After that you simply add <span class="italic">X</span> to the 2’s complemented form of <span class="italic">Y</span> to get <span class="italic">X</span>−<span class="italic">Y</span>. When the add/subtract switch is thrown to the subtract position, one input to each XOR gate is set high. This causes the <span class="italic">Y</span> bits that are applied to the other XOR inputs to become inverted at the XOR outputs—you have just taken the 1’s complement of <span class="italic">Y</span>. The 1’s complement bits of <span class="italic">Y</span> are then presented to the inputs of the 8-bit adder. At the same time, <span class="italic">C</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">in</span></small></sub> of the left 74LS283 is set high via the wire (see <a href="#filepos2732517">Fig. 12.47</a>) so that a 1 is added to the 1’s complement number to yield a 2’s complement number. The 8-bit adder then adds <span class="italic">X</span> and the 2’s complement of <span class="italic">Y</span> together. The final result is presented at the Σ outputs. In the figure, 76 is subtracted from 28.</span></div>
<div id="filepos2734489" class="calibre48"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.3.6   Arithmetic Logic Units</span></span></span></span></span></div>
<div class="calibre11"><span>An ALU is a multipurpose integrated circuit capable of performing various arithmetic and logic operations. To choose a specific operation to be performed, a binary code is applied to the IC’s mode select inputs. The 74181, shown in <a href="#filepos2735090">Fig. 12.48</a>, is a 4-bit ALU that provides 16 arithmetic and 16 logic operations.</span></div>
<div id="filepos2735090" class="calibre3"><span><img alt="image" src="images/01729.jpg" class="calibre640"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.48</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>To select an arithmetic operation, the 74181’s mode control input (<span class="italic">M</span>) is set low. To select a logic operation, the mode control input is set high. Once you have decided whether you want to perform a logic or arithmetic operation, you apply a 4-bit code to the mode select inputs (<span class="italic">S</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">0</span></small></sub>, <span class="italic">S</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">1</span></small></sub>, <span class="italic">S</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">2</span></small></sub>, and <span class="italic">S</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">3</span></small></sub>) to specify which specific operation, as indicated within the truth table, is to be performed. For example, if you select <span class="italic">S</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">3</span></small></sub> = 1, <span class="italic">S</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">2</span></small></sub> = 1, <span class="italic">S</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">1</span></small></sub> = 1, <span class="italic">S</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">0</span></small></sub> = 0, while <span class="italic">M</span> = 1, then you get <span class="italic">F</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">0</span></small></sub> = <span class="italic">A</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">0</span></small></sub> + <span class="italic">B</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">0</span></small></sub>, <span class="italic">F</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">1</span></small></sub> = <span class="italic">A</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">1</span></small></sub> + <span class="italic">B</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">1</span></small></sub>, <span class="italic">F</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">2</span></small></sub> = <span class="italic">A</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">2</span></small></sub> + <span class="italic">B</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">2</span></small></sub>, <span class="italic">F</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">3</span></small></sub> = <span class="italic">A</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">3</span></small></sub> + <span class="italic">B</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">3</span></small></sub>. Note that the + shown in the truth table does not represent addition; it is used to represent the OR function. For addition, the tables use “plus.” Carry-in (<img alt="image" src="images/01681.jpg" class="calibre1492"/><sub class="calibre37"><small class="calibre28"><span class="calibre17"><span class="italic">N</span></span></small></sub>) and carry-out (<span class="italic">C</span><sub class="calibre37"><small class="calibre28"><span class="calibre17"><span class="italic">N</span> + 4</span></small></sub>) leads are provided for use in arithmetic operations. All arithmetic results generated by this device are in 2’s complement notation.</span></div>
<div id="filepos2737646" class="calibre48"><span class="bold"><span class="italic"><span><a></a><span class="bold"><span class="italic">12.3.7   Comparators and Magnitude Comparator ICs</span></span></span></span></span></div>
<div class="calibre11"><span>A digital comparator is a circuit that accepts two binary numbers and determines whether the two numbers are equal. For example, <a href="#filepos2738587">Fig. 12.49</a> shows a 1-bit and a 4-bit comparator. The 1-bit comparator outputs a high (1) only when the two 1-bit numbers <span class="italic">A</span> and <span class="italic">B</span> are equal. If <span class="italic">A</span> is not equal to <span class="italic">B</span>, then the output goes low (0). The 4-bit is basically four 1-bit comparators in one. When all individual digits of each number are equal, all XOR gates output a high, which in turn enables the AND gate, making the output high. If any two corresponding digits of the two numbers are not equal, the output goes low.</span></div>
<div id="filepos2738587" class="calibre3"><span><img alt="image" src="images/01730.jpg" class="calibre526"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.49</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span><a></a>Now, say you want to know which number, <span class="italic">A</span> or <span class="italic">B</span>, is larger. The circuits in <a href="#filepos2738587">Fig. 12.49</a> will not do the trick. What you need instead is a <span class="italic">magnitude comparator</span> like the 74HC85 shown in <a href="#filepos2740960">Fig. 12.50</a>. This device not only tells you if two numbers are equal, but also which number is larger. For example, if you apply a 1001 (9<sub class="calibre37"><small class="calibre28"><span class="calibre17">10</span></small></sub>) to the <span class="italic">A</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">3</span></small></sub><span class="italic">A</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">2</span></small></sub><span class="italic">A</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">1</span></small></sub><span class="italic">A</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">0</span></small></sub> inputs and a second number 1100 (12<sub class="calibre37"><small class="calibre28"><span class="calibre17">10</span></small></sub>) to the <span class="italic">B</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">3</span></small></sub><span class="italic">B</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">2</span></small></sub><span class="italic">B</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">1</span></small></sub><span class="italic">B</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">0</span></small></sub> inputs, the <span class="italic">A</span> &lt; <span class="italic">B</span> output will go high (the other two outputs, <span class="italic">A</span> &gt; <span class="italic">B</span> and <span class="italic">A = B</span>, will remain low). If <span class="italic">A</span> and <span class="italic">B</span> were equal, the <span class="italic">A = B</span> output would have gone high, and so on. If you wanted to compare larger numbers—say, two 8-bit numbers—you simply cascade two 74HC85 comparators together, as shown on the right side of <a href="#filepos2740960">Fig. 12.50</a>. The leftmost 74HC85 compares the lower-order bits, while the rightmost 74HC85 compares the higher-order bits. To link the two devices together, you connect the output of the lower-order device to the expansion inputs of the higher-order device, as shown. The lower-order device’s expansion inputs are always set low (<span class="italic">I<sub class="calibre37"><small class="calibre28"><span class="calibre17">A</span></small></sub> &lt; B</span>), high (<span class="italic">I<sub class="calibre37"><small class="calibre28"><span class="calibre17">A</span></small></sub> = B</span>), and low (<span class="italic">I<sub class="calibre37"><small class="calibre28"><span class="calibre17">A</span></small></sub> &gt; B</span>).</span></div>
<div id="filepos2740960" class="calibre3"><span><img alt="image" src="images/01731.jpg" class="calibre278"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.50</span></span></span></div><div class="calibre35"> </div>
<div id="filepos2741236" class="calibre3"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.3.8   Parity Generator/Checker</span></span></span></span></span></div>
<div class="calibre11"><span>Often, external noise can corrupt binary information (cause a bit to flip from one logic state to the other) as it travels along a conductor from one device to the next. For example, in the 4-bit system shown in <a href="#filepos2741918">Fig. 12.51</a>, a BCD 4 (0100) picks up noise and becomes 0101 (or 5) before reaching its destination. Depending on the application, this type of error could lead to some serious problems.</span></div>
<div id="filepos2741918" class="calibre3"><span><img alt="image" src="images/01732.jpg" class="calibre669"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.51</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>To avoid problems caused by unwanted data corruption, a parity generator/checker system, like the one shown in <a href="#filepos2741918">Fig. 12.51</a>, can be used. The basic idea is to add an extra bit, called a parity bit, to the digital information being transmitted. If the <span class="italic">parity bit</span> makes the sum of all transmitted bits (including the parity bit) odd, the transmitted information is of odd parity. If the parity bit makes the sum even, the transmitted information is of even parity. A parity generator circuit creates the parity bit, while the parity checker on the receiving end determines if the information sent is of the proper parity. The type of parity (odd or even) is agreed to beforehand, so the parity checker knows what to look for. The parity bit can be placed next to the MSB or the LSB, provided the device on the receiving end knows which bit is the parity bit and which bits are the data. The arrangement shown in <a href="#filepos2741918">Fig. 12.51</a> is designed with an even-parity error-detection system.</span></div>
<div class="calibre26"><span><a></a>If you want to avoid building parity generators and checkers from scratch, use a parity generator/checker IC like the 74F280 9-bit odd-even parity generator/checker shown in <a href="#filepos2744540">Fig. 12.52</a>. To make a complete error-detection system, two 74F280s are used: one acts as the parity generator, and the other acts as the parity checker. The generator’s inputs <span class="italic">A</span> through <span class="italic">H</span> are connected to the eight data lines of the transmitting portion of the circuit. The ninth input (I) is grounded when the device is used as a generator. If you want to create an odd-parity generator, you tap the Σ<sub class="calibre37"><small class="calibre28"><span class="calibre17">odd</span></small></sub> output; for even parity, you tap Σ<sub class="calibre37"><small class="calibre28"><span class="calibre17">even</span></small></sub>. The 74F280 checker taps the main line at the receiving end and also accepts the parity bit line at input <span class="italic">I</span>. <a href="#filepos2744540">Figure 12.52</a> shows an odd-parity error-detection system used with an 8-bit system. If an error occurs, a high (1) is generated at the Σ<sub class="calibre37"><small class="calibre28"><span class="calibre17">odd</span></small></sub> output.</span></div>
<div id="filepos2744540" class="calibre3"><span><img alt="image" src="images/01733.jpg" class="calibre122"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.52</span></span></span></div><div class="calibre35"> </div>
<div id="filepos2744816" class="calibre3"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.3.9   A Note on Obsolescence and the Trend Toward Microcontroller Control</span></span></span></span></span></div>
<div class="calibre11"><span>We have just covered most of the combinational devices you will find discussed in textbooks and listed within electronic catalogs. Many of these devices are still used. However, some devices, such as the binary adders and code converters, are obsolete.</span></div>
<div class="calibre26"><span>Today, the trend is to use software-controlled devices such as microprocessors and microcontrollers to carry out arithmetic operations and code conversions. Before you attempt to design any logic circuit, I suggest jumping to <a href="CR%21QKYKJ7KY3158K36EJE0G9AYNF2ZW_split_019.html#filepos3084490">Chapter 13</a>, which covers microcontrollers.</span></div>
<div class="calibre26"><span>Microcontrollers can be used to collect data, store data, and perform logical operations using the input data. They also can generate output signals that can be used to control displays, audio devices, stepper motors, servos, and so on. The specific functions a microcontroller is designed to perform depend on the program you store in its internal ROM-type memory.</span></div>
<div class="calibre26"><span>Programming the microcontroller typically involves simply using a special programming unit provided by the manufacturer. The programming unit usually consists of a prototyping platform that is linked to a host computer (via a USB port) that is running a development environment. In the development environment, you typically write out a program in a high-level language such as C, or some other specialized language designed for a certain microcontroller, and then, with the press of a key, the program is converted into machine language (1s and 0s) and downloaded into the microcontroller’s memory.</span></div>
<div class="calibre26"><span><a></a>In many applications, a single microcontroller can replace entire logic circuits composed of numerous discrete components. For this reason, it is tempting to skip the rest of this chapter and go directly to the chapter on microcontrollers. However, there are three basic problems with this approach:</span></div>
<div class="calibre187"><span>•  If you are a beginner, you will miss out on many important principles behind digital control that are most easily understood by learning how the discrete components work.</span></div>
<div class="calibre27"><span>•  Many digital circuits that you can build simply do not require the amount of sophistication a microcontroller provides.</span></div>
<div class="calibre27"><span>•  You may feel intimidated by the electronics catalogs that list every conceivable component available (even those that are obsolete). Knowing what’s out there and knowing what to avoid are also important parts of the learning process.</span></div>
<div id="filepos2748176" class="calibre3"><span class="calibre7"><span><span class="bold">12.4   Logic Families</span></span></span></div>
<div class="calibre11"><span><img alt="image" src="images/00007.jpg" class="calibre36"/></span></div>
<div class="calibre11"><span>Before moving on to sequential logic, let’s touch on a few practical matters regarding the various logic families available and what kind of operating characteristics these families have. In this section, you will also encounter unique logic gates that have open-collector output stages and logic gates that have Schmitt-triggered inputs.</span></div>
<div class="calibre26"><span>The key ingredient within any integrated logic device—a logic gate, a multiplexer, or a microprocessor—is the transistor. The kinds of transistors used within the IC, to a large extent, specify the type of logic family. The two most popular transistors used in ICs are bipolar and MOSFET transistors.</span></div>
<div class="calibre26"><span>In general, ICs made from MOSFET transistors use less space due to their simpler construction, have very high noise immunity, and consume less power than equivalent bipolar transistor ICs. However, the high-input impedance and input capacitance of the MOSFET transistors (due to their insulated gate leads) result in longer time constants for transistor on/off switching speeds when compared with bipolar gates, and therefore typically result in a slower device. Over years of development, however, the performance gap between these two technologies has narrowed considerably.</span></div>
<div class="calibre26"><span><a></a>Both the bipolar and MOSFET logic families can be divided into a number of subclasses. The major subclasses of the bipolar family include transistor-transistor logic (TTL), emitter-coupled logic (ECL), and integrated-injection logic (IIL or I<sup class="calibre29"><small class="calibre28"><span class="calibre17">2</span></small></sup>L). The major subclasses of the MOSFET logic include P-channel MOSFET (PMOS), N-channel MOSFET (NMOS), and complementary MOSFET (CMOS). CMOS uses both NMOS and PMOS technologies. The two most popular technologies are TTL and CMOS. The other technologies are typically used in large-scale integration devices, such as microprocessors and memories. There are new technologies popping up all the time, which yield faster, more energy-efficient devices. Some examples include BiCMOS, GaAS, SOS, and Josephson junction technologies.</span></div>
<div class="calibre3"><span><img alt="image" src="images/01734.jpg" class="calibre1511"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.53</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>As you have already learned, TTL and CMOS devices are grouped into functional categories that get placed into either the 7400 series (74F, 74LS, 74HC (CMOS), and so on) or 4000 CMOS series (or the improved 4000B series). Another series you will run into is the 5400 series. This series is essentially equivalent to the 7400 series (with the same pinouts and same basic logic function), but it is a more expensive chip because it is designed for military applications that require increased supply voltage tolerances and temperature tolerances. For example, a 7400 IC typically has a supply voltage range from 4.75 to 5.25 <span class="italic">V</span> with a temperature range from 0 to 70°C. A 5400 IC typically has a voltage range between 4.5 and 5.5 <span class="italic">V</span> and a temperature range from -55 to 125°C.</span></div>
<div id="filepos2752067" class="calibre48"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.4.1   TTL Family of ICs</span></span></span></span></span></div>
<div class="calibre11"><span>The original TTL series, referred to as the <span class="italic">standard TTL</span> series (74xx), was developed early in the 1960s. This series is still in use, even though its overall performance is inferior to the newer line of TTL devices, such as the 74LSxx, 74ALSxx, and 74Fxx. The internal circuitry of a standard TTL 7400 NAND gate, along with a description of how it works, is provided next.</span></div>
<div class="calibre3"><span><img alt="image" src="images/01735.jpg" class="calibre1512"/></span></div>
<div class="calibre3"><span><img alt="image" src="images/01736.jpg" class="calibre170"/></span></div>
<div class="calibre6"><span class="calibre17"><span class="bold"><span><a></a>The TTL NAND gate is divided into three basic sections: multi-emitter input, control section, and totem-pole output stage. In the multi-emitter input section, a multi-emitter bipolar transistor <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">1</span></small></sub> acts like a two-input AND gate, while diodes <span class="italic">D</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">1</span></small></sub> and <span class="italic">D</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">2</span></small></sub> act as negative clamping diodes used to protect the inputs from any short-term negative input voltages that could damage the transistor. <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">2</span></small></sub> provides control and current boosting to the totem-pole output stage; when the output is high (1), <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">4</span></small></sub> is off (open) and <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">3</span></small></sub> is on (short). When the output is low (0), <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">4</span></small></sub> is on and <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">3</span></small></sub> is off. Because one or the other transistor is always off, the current flow from <span class="italic">V<sub class="calibre37"><small class="calibre28"><span class="calibre17">CC</span></small></sub></span> to ground in that section of the circuit is minimized. The lower figures show both a high and low output state, along with the approximate voltages present at various locations. Notice that the actual output voltages are not exactly 0 or +5 V—a result of internal voltage drops across resistor, transistor, and diode. Instead, the outputs are around 3.4 <span class="italic">V</span> for high and 0.3 <span class="italic">V</span> for low. Note that to create, say, an eight-input NAND gate, the multi-emitter input transistor would have eight emitters instead of just two as shown.</span></span></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.54</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>A simple modification to the standard TTL series was made early on by reducing all the internal resistor values in order to reduce the <span class="italic">RC</span> time constants and thus increase the speed (reduce propagation delays). This improvement to the original TTL series marked the 74H series. Although the 74H series offered improved speed (about twice as fast) over the 74 series, it had more than double the power consumption. Later, the 74L series emerged. Unlike the 74H, the 74L took the 74 and increased all internal resistances. The net effect led to a reduction in power but increased propagation delay.</span></div>
<div class="calibre26"><span>A significant improvement in speed within the TTL line emerged with the development of the 74S<span class="italic">xx</span> series (Schottky TTL series). The key modifications involved placing Schottky diodes across the base-to-collector junctions of the transistors. These Schottky diodes eliminated capacitive effects caused by charge buildup in the transistor’s base region by passing the charge to the collector region. Schottky diodes were the best choice because of their inherent low charge buildup characteristics. The overall effect was an increase in speed by a factor of 5 and only a doubling in power.</span></div>
<div class="calibre26"><span>Continually over time, by using different integration techniques and increasing the values of the internal resistors, more power-efficient series emerged, like the low-power Schottky 74LS series, with about one-third the power dissipation of the 74S. After the 74LS, the advanced-low-power Schottky 74ALS series emerged, which had even better performance. Another series developed around this time was the 74F series, or FAST logic, which used a new process of integration called <span class="italic">oxide isolation</span> (also used in the ALS series) that led to reduced propagation delays and decreased the overall size.</span></div>
<div class="calibre26"><span>Today you will find many of the older series listed in electronics catalogs. Which series you choose ultimately depends on availability, cost, and what kind of performance you are seeking.</span></div>
<div id="filepos2757311" class="calibre48"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.4.2   CMOS Family of ICs</span></span></span></span></span></div>
<div class="calibre11"><span>While the TTL series was going through its various transformations, the CMOS series entered the picture. The original CMOS 4000 series (or the improved 4000B series) was developed to offer lower power consumption than the TTL series of devices—a feature made possible by the high input impedance characteristics of its MOSFET transistors. The 4000B series also offered a larger supply voltage range (3 to 18 V), with minimum logic high = <img alt="image" src="images/01595.jpg" class="calibre1425"/><span class="italic">V<sub class="calibre37"><small class="calibre28"><span class="calibre17">DD</span></small></sub></span> and maximum logic low = <img alt="image" src="images/01594.jpg" class="calibre1425"/><span class="italic">V<sub class="calibre37"><small class="calibre28"><span class="calibre17">DD</span></small></sub></span>. The 4000B series, though more energy efficient than the TTL series, was significantly slower and more susceptible to damage due to electrostatic discharge. <a href="#filepos2758696">Figure 12.55</a> shows the internal circuitry of CMOS NAND, AND, and NOR gates. To figure out how the gates work, apply high (logic 1) or low (logic 0) levels to the inputs and see which transistor gates turn on and which transistor gates turn off.</span></div>
<div id="filepos2758696" class="calibre3"><span><img alt="image" src="images/01737.jpg" class="calibre38"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.55</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>A further improvement in speed over the original 4000B series came with the introduction of the 40H00 series. Although this series was faster than the 4000B series, it was not quite as fast as the 74LS TTL series. The 74C CMOS series also emerged on the scene, which was designed specifically to be pin-compatible with the TTL line.</span></div>
<div class="calibre26"><span><a></a>Another significant improvement in the CMOS family came with the development of the 74HC and the 74HCT series. Both these series, like the 74C series, were pin-compatible with the TTL 74 series. The 74HC (high-speed CMOS) series had the same speed as the 74LS, as well as the traditional CMOS low-power consumption. The 74HCT (high-speed CMOS TTL compatible) series was developed to be interchangeable with TTL devices (same I/O voltage level characteristics). The 74HC series is very popular today.</span></div>
<div class="calibre26"><span>Still further improvements in 74HC/74HCT series led to the advanced CMOS logic (74AC/74ACT) series. The 74AC (advanced CMOS) series approached speeds comparable with the 74F TTL series, while the 74ACT (advanced CMOS TTL compatible) series was designed to be TTL compatible.</span></div>
<div id="filepos2760354" class="calibre48"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.4.3   I/O Voltages and Noise Margins</span></span></span></span></span></div>
<div class="calibre11"><span>The exact input voltage levels required for a logic IC to perceive a high (logic 1) or low (logic 0) input level differ between the various logic families. At the same time, the high and low output levels provided by a logic IC vary among the logic families. For example, <a href="#filepos2761021">Fig. 12.56</a> shows valid input and output voltage levels for both the 74LS (TTL) and 74HC (CMOS) families.</span></div>
<div id="filepos2761021" class="calibre3"><span><img alt="image" src="images/01738.jpg" class="calibre1275"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.56</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span><a></a>In <a href="#filepos2761021">Fig. 12.56</a>, the voltage ranges are represented as follows:</span></div>
<div class="calibre187"><span>•  <span class="italic">V<sub class="calibre37"><small class="calibre28"><span class="calibre17">IH</span></small></sub></span> represents the valid voltage range that will be interpreted as a high logic input level.</span></div>
<div class="calibre27"><span>•  <span class="italic">V<sub class="calibre37"><small class="calibre28"><span class="calibre17">IL</span></small></sub></span> represents the valid voltage range that will be interpreted as a low logic input level.</span></div>
<div class="calibre27"><span>•  <span class="italic">V<sub class="calibre37"><small class="calibre28"><span class="calibre17">OL</span></small></sub></span> represents the valid voltage range that will be guaranteed as a low logic output level.</span></div>
<div class="calibre27"><span>•  <span class="italic">V<sub class="calibre37"><small class="calibre28"><span class="calibre17">OH</span></small></sub></span> represents the valid voltage range that will be guaranteed as a high logic output level.</span></div>
<div class="calibre30"><span>As you can see from <a href="#filepos2761021">Fig. 12.56</a>, if you connect the output of a 74HC device to the input of a 74LS device, there is no problem—the output logic levels of the 74HC are within the valid input range of the 74LS. However, if you turn things around, driving a 74HC device’s inputs from a 74LS’s output, you have problems—a high output level from the 74LS is too small to be interpreted as a high input level for the 74HC. <a href="#filepos2781358">Section 12.4.9</a> shows some tricks used to interface the various logic families together.</span></div>
<div id="filepos2763207" class="calibre48"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.4.4   Current Ratings, Fanout, and Propagation Delays</span></span></span></span></span></div>
<div class="calibre11"><span>Logic IC inputs and outputs can sink or source only a given amount of current. <span class="italic">I<sub class="calibre37"><small class="calibre28"><span class="calibre17">IL</span></small></sub></span> is defined as the maximum low-level input current, <span class="italic">I<sub class="calibre37"><small class="calibre28"><span class="calibre17">IH</span></small></sub></span> as the maximum high-level input current, <span class="italic">I</span><sub class="calibre37"><small class="calibre28"><span class="calibre17"><span class="italic">OH</span></span></small></sub> as the maximum high-level output current, and <span class="italic">I<sub class="calibre37"><small class="calibre28"><span class="calibre17">OL</span></small></sub></span> as the maximum low-level output current. As an example, a standard 74<span class="italic">xx</span> TTL gate may have an <span class="italic">I<sub class="calibre37"><small class="calibre28"><span class="calibre17">L</span></small></sub></span> = −1.6 mA and <span class="italic">I<sub class="calibre37"><small class="calibre28"><span class="calibre17">IH</span></small></sub></span> = 40 μA while having an <span class="italic">I<sub class="calibre37"><small class="calibre28"><span class="calibre17">OL</span></small></sub></span> = 16 mA and <span class="italic">I</span><sub class="calibre37"><small class="calibre28"><span class="calibre17"><span class="italic">OH</span></span></small></sub> = −400 μA. The negative sign means that current is leaving the gate (the gate is acting as a source). A positive sign means that current is entering the gate (the gate is acting as sink).</span></div>
<div class="calibre26"><span>The limit to how much current a device can sink or source determines the size of loads that can be attached. The term <span class="italic">fanout</span> is used to specify the total number of gates that can be driven by a single gate of the same family without exceeding the current rating of the gate. The fanout is determined by taking the smaller result of <span class="italic">I<sub class="calibre37"><small class="calibre28"><span class="calibre17">OL</span></small></sub></span>/<span class="italic">I<sub class="calibre37"><small class="calibre28"><span class="calibre17">IL</span></small></sub></span> or <span class="italic">I<sub class="calibre37"><small class="calibre28"><span class="calibre17">OH</span></small></sub></span>/<span class="italic">I<sub class="calibre37"><small class="calibre28"><span class="calibre17">IH</span></small></sub></span>. For the standard 74 series, the fanout is 10 (16 mA/1.6 mA). For the 74LS series, the fanout is around 20; for the 74F, it is around 33; and for the 7HC, it is around 50.</span></div>
<div class="calibre26"><span>If you apply a square pulse to the input of a logic gate, the output signal will experience a sloping rise time and fall time, as shown in the graph in <a href="#filepos2765993">Fig. 12.57</a>. The <span class="italic">rise time</span> (<span class="italic">tr</span>) is the length of time it takes for a pulse to rise from 10 to 90 percent of its high level (e.g., 5 <span class="italic">V</span> = high: 0.5 <span class="italic">V</span> = 10%, 4.5 <span class="italic">V</span> = 90%). <span class="italic">The fall time</span> (<span class="italic">tf</span>) is the length of time it takes for a high level to fall from the 90 to 10 percent.</span></div>
<div id="filepos2765993" class="calibre3"><span><img alt="image" src="images/01739.jpg" class="calibre164"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.57</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span><a></a>The rise and fall times, however, are not as significant when compared with propagation delays between input transition and output response. Propagation delay results from the limited switching speeds of the internal transistors within the logic device. The low-to-high propagation delay <span class="italic">T<sub class="calibre37"><small class="calibre28"><span class="calibre17">PHL</span></small></sub></span> is the time it takes for the output of a device to switch from low to high after the input transition. The high-to-low propagation delay <span class="italic">T<sub class="calibre37"><small class="calibre28"><span class="calibre17">PLH</span></small></sub></span> is the time it takes for the output to switch from high to low after the input transition. When designing circuits, it is important to take into account these delays, especially when you start dealing with sequential logic, where timing is everything. <a href="#filepos2767396">Figs. 12.58</a> and <a href="#filepos2767672">12.59</a> provide typical propagation delays for various TTL and CMOS devices. Manufacturers will provide more accurate propagation information in their data sheets.</span></div>
<div id="filepos2767396" class="calibre3"><span><img alt="image" src="images/01740.jpg" class="calibre1217"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.58</span></span></span></div><div class="calibre35"> </div>
<div id="filepos2767672" class="calibre3"><span><img alt="image" src="images/01741.jpg" class="calibre1513"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span><a></a>FIGURE 12.59</span></span></span></div><div class="calibre35"> </div>
<div id="filepos2767955" class="calibre48"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.4.5   A Detailed Look at the TTL and CMOS Subfamilies</span></span></span></span></span></div>
<div class="calibre11"><span>The information shown in <a href="#filepos2767396">Figs. 12.58</a> and <a href="#filepos2767672">12.59</a>, especially the data pertaining to propagation delays and current ratings, represents <span class="italic">typical values</span> for a given logic series. For more accurate data about a specific device, you must consult the manufacturer’s literature. In other words, use the provided information only as a rough guide to get a feeling for the overall performance of a given logic series.</span></div>
<div id="filepos2768710" class="calibre48"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.4.6   A Look at a Few Other Logic Series</span></span></span></span></span></div>
<div class="calibre3"><span><span class="bold">The 74-BiCMOS Series</span></span></div>
<div class="calibre11"><span>The 74-BiCMOS series of devices incorporates the best features of bipolar and CMOS technology together in one package. The overall effect is an extremely high-speed, low-power digital logic family. This product line is especially well suited for, and mostly limited to, microprocessor bus interface logic. Each manufacturer uses a different suffix to identify its BiCMOS line. For example, Texas Instruments uses 74BCT<span class="italic">xx</span>, while Signetics (Phillips) uses 74ABT<span class="italic">xx</span>.</span></div>
<div class="calibre3"><span><span class="bold">The 74-Low-Voltage Series</span></span></div>
<div class="calibre11"><span>The 74-low-voltage series is a relatively new series that uses a nominal supply voltage of 3.3 V. Members of this series include the 74LV (low-voltage HCMOS), 74LVC (low-voltage CMOS), 74LVT (low-voltage technology), and 74ALVC (advanced low-voltage CMOS). See <a href="#filepos2770076">Fig. 12.60</a>.</span></div>
<div id="filepos2770076" class="calibre3"><span><img alt="image" src="images/01742.jpg" class="calibre1514"/></span></div>
<div class="calibre6"><span class="calibre17"><span class="bold"><span><a></a>A relatively new series of logic uses a nominal supply voltage of 3.3 <span class="italic">V</span> and is designed for extremely low-power and low-voltage applications (such as battery-powered devices). The switching speed of LV logic is extremely fast, ranging from about 9 ns for the LB series down to 2.1 ns for the ALVC. Another nice feature of LV logic is high output drive capability. The LVT, for example, can sink up to 64 mA and source up to 32 mA.</span></span></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.60</span></span></span></div><div class="calibre35"> </div>
<div class="calibre3"><span><span class="bold">Emitter-Coupled Logic</span></span></div>
<div class="calibre11"><span><a></a>Emitter-coupled logic (ECL), a member of the bipolar family, was used for extremely high-speed applications, reaching speeds up to 500 MHz with propagation delays as low as 0.8 ns. There is one problem with ECL: it consumes a considerable amount of power when compared with the TTL and CMOS series.</span></div>
<div class="calibre26"><span>ECL is obsolete now, but was used in computer systems, where power consumption is not as big an issue as speed. The trick to getting the bipolar transistors in an ECL device to respond so quickly is to never let the transistors saturate. Instead, high and low levels are determined by which transistor in a differential amplifier is conducting more. <a href="#filepos2772159">Figure 12.61</a> shows the internal circuitry of an OR/NOR ECL gate. The high and low logic-level voltages (−0.8 and −17 V, respectively) and the supply voltage (−5.2 V/0 V) are somewhat unusual and cause problems when interfacing with TTL and CMOS.</span></div>
<div id="filepos2772159" class="calibre3"><span><img alt="image" src="images/01743.jpg" class="calibre1515"/></span></div>
<div class="calibre6"><span class="calibre17"><span class="bold"><span>The OR/NOR gate shown here is composed of a differential amplifier input stage and an output stage. In the differential amplifier stage, a reference voltage is set up at <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">3</span></small></sub>’s base via the voltage divider network (diodes/resistors). This reference voltage determines the threshold between high and low logic levels. When the base of <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">3</span></small></sub> is at a more positive potential with respect to the emitter of <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">1</span></small></sub> and <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">2</span></small></sub>, <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">3</span></small></sub> conducts. When <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">5</span></small></sub> conducts, the OR output goes low. If either input A or B is raised to −0.8 <span class="italic">V</span> (high), the base of <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">1</span></small></sub> or <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">2</span></small></sub> will be at a higher potential than the base of <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">3</span></small></sub>, and <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">3</span></small></sub> will cease conducting, forcing the OR output high. The overall effect of the ECL design prevents transistors from saturating, thereby eliminating charge buildup on the base of the transistors that limits switching speeds.</span></span></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.61</span></span></span></div><div class="calibre35"> </div>
<div id="filepos2773951" class="calibre3"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.4.7   Logic Gates with Open-Collector Outputs</span></span></span></span></span></div>
<div class="calibre11"><span>Among the members of the TTL series is a special class of logic gates that have open-collector output stages instead of the traditional totem-pole configuration you saw earlier. (Within the CMOS family, there are similar devices that are said to have open-drain output stages). These devices are not to be confused with the typical logic gates you have seen so far. Logic gates with open-collector outputs have entirely different output characteristics.</span></div>
<div class="calibre26"><span><a href="#filepos2775372">Figure 12.62</a> shows a NAND gate with open-collector (OC) output. Notice that the <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">3</span></small></sub> transistor is missing in the OC NAND gate. By removing <span class="italic">Q</span><sub class="calibre37"><small class="calibre28"><span class="calibre17">3</span></small></sub>, the output no longer goes high when <span class="italic">A</span> and <span class="italic">B</span> logic levels are set to 00, 01, or 10. Instead, the output floats. When <span class="italic">A</span> and <span class="italic">B</span> logic levels are both high (1), the output is grounded. This means that the OC gate can only sink current; it cannot source current! So how do you get a high output level?</span></div>
<div id="filepos2775372" class="calibre3"><span><img alt="image" src="images/01744.jpg" class="calibre827"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.62</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>You use an external voltage source and a pullup resistor, as shown in the center of <a href="#filepos2775372">Fig. 12.62</a>. Now, when the output floats, the pullup resistor connected to the external voltage source will “pull” the output to the same level as the external voltage source, which in this case is at +15 V. That’s right—you don’t need to use +5 V. That is one of the primary benefits of using OC gates: you can drive load-requiring voltage levels different from those of the logic circuitry.</span></div>
<div class="calibre26"><span><a></a>Another important feature of OC gates is their ability to sink large amounts of currents. For example, the 7406 OC inverter buffer/driver IC is capable of sinking 40 mA, which is 2.5 times the amount of current a standard 7404 inverter can sink. (The 7404 OC buffer/driver has the same sinking ability as the 7406 OC, but does not provide any logic function; it simply acts as a buffer stage.) The ability for an OC gate to sink a reasonably large current makes it useful for driving LED displays and other higher-current loads. <a href="#filepos2776977">Figure 12.63</a> shows a number of OC logic gate ICs.</span></div>
<div id="filepos2776977" class="calibre3"><span><img alt="image" src="images/01745.jpg" class="calibre169"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.63</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>OC gates are also useful in instances where the output from two or more gates or other devices must be tied together. When you use standard gates with totem-pole output stages, if one gate outputs a high (+5 V) while another gate outputs a low (0 V), a direct short circuit is also created, which can cause either or both gates to burn out. By using OC gates, this problem can be avoided.</span></div>
<div class="calibre26"><span>When working with OC gates, you cannot apply the same Boolean rules you used earlier with the standard gates. Instead, you must use what is called wired-AND logic, which amounts to simply ANDing all gates together, as shown in <a href="#filepos2775372">Fig. 12.62</a>. In other words, the outputs of all the gates must float in order to get a high output level.</span></div>
<div id="filepos2778179" class="calibre48"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.4.8   Schmitt-Triggered Gates</span></span></span></span></span></div>
<div class="calibre11"><span>Schmitt-triggered gates are special-purpose logic gates that come with Schmitt-triggered inputs. Unlike the conventional logic gates, Schmitt-triggered gates have two input threshold voltages: the <span class="italic">positive threshold voltage</span> (<img alt="image" src="images/01746.jpg" class="calibre1516"/>) and the <span class="italic">negative threshold voltage</span> (<img alt="image" src="images/01747.jpg" class="calibre1516"/>). Example Schmitt-triggered ICs include the quad 7414 inverter, the quad 2-input NAND gate, and the dual 4-input NAND gate shown in <a href="#filepos2779000">Fig. 12.64</a>.</span></div>
<div id="filepos2779000" class="calibre3"><span><img alt="image" src="images/01748.jpg" class="calibre168"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.64</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span><a></a>To get a sense of how these devices work, let’s compare the Schmitt-triggered 7414 inverter gate with a conventional inverter gate, the 7404. With the 7404, to make the output go from high to low or from low to high, the input voltage must fall above or below the single 2.0-V threshold voltage. However, with the 7414, to make the output go from low to high, the input voltage must dip below <img alt="image" src="images/01747.jpg" class="calibre1516"/> (which is +0.9 V for this particular IC). To make the output go from high to low, the input voltage must pop above <img alt="image" src="images/01746.jpg" class="calibre1516"/> (which is +1.7 V for this particular IC). The difference in voltage between <img alt="image" src="images/01746.jpg" class="calibre1516"/> and <img alt="image" src="images/01747.jpg" class="calibre1516"/> is called the <span class="italic">hysteresis voltage</span> (see <a href="CR%21QKYKJ7KY3158K36EJE0G9AYNF2ZW_split_014.html#filepos2297020">Chapter 8</a> for details). The symbol used to designate a Schmitt trigger is based on the appearance of its transfer function, as shown in <a href="#filepos2780450">Fig. 12.65</a>.</span></div>
<div id="filepos2780450" class="calibre3"><span><img alt="image" src="images/01749.jpg" class="calibre281"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.65</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>In terms of applications, Schmitt-triggered devices are quite handy for transforming noisy signals or signals that waver around critical threshold levels into sharply defined, jitter-free output signals. This is illustrated in the lower graphs shown in <a href="#filepos2780450">Fig. 12.65</a>. The conventional 7404 experiences an unwanted output spike resulting from a short-term spike present during low-to-high and high-to-low input voltage transitions. The Schmitt-triggered inverter ignores these spikes because it incorporates hysteresis.</span></div>
<div id="filepos2781358" class="calibre48"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.4.9   Interfacing Logic Families</span></span></span></span></span></div>
<div class="calibre11"><span><a></a>Mixing of logic families, in general, should be avoided. Obvious reasons for not mixing include differences in I/O logic levels, supply voltages, and output drive capability that exist among the various families. Another important reason involves differences in speed between the various families; if you mix slow-logic ICs with faster-logic ICs, you can run into timing problems.</span></div>
<div class="calibre26"><span>There are times, however, when mixing is unavoidable or even desirable. For example, perhaps a desired special-purpose device (such as memory or a counter) exists only in CMOS, but the rest of your system consists of TTL. Mixing of families is also common when driving loads. For example, a TTL gate (often with an open-collector output) is frequently used as an interface between a CMOS circuit and an external load, such as LED indicator lights. A CMOS output, by itself, usually does not provide sufficient drive current to power such loads. I will discuss driving loads in <a href="CR%21QKYKJ7KY3158K36EJE0G9AYNF2ZW_split_018.html#filepos2942250">Section 12.10</a>.</span></div>
<div class="calibre26"><span><a></a><a href="#filepos2783102">Figure 12.66</a> shows tricks for interfacing various logic families. These tricks take care of I/O incompatibility problems as well as supply voltage incompatibility problems. The tricks, however, do not take care of any timing incompatibility problems that may arise.</span></div>
<div id="filepos2783102" class="calibre3"><span><img alt="image" src="images/01750.jpg" class="calibre1517"/></span></div>
<div class="calibre6"><span class="calibre17"><span class="bold"><span>Figure a. TTL can be directly interfaced with itself or with HCT or ACT.</span></span></span></div>
<div class="calibre26"><span class="calibre17"><span class="bold"><span>Figure b. CMOS 74C/4000(B) with <span class="italic">V<sub class="calibre37"><small class="calibre28"><span class="calibre17">DD</span></small></sub></span> = +5 <span class="italic">V</span> can drive TTL, HC, HCT, AC, or ACT.</span></span></span></div>
<div class="calibre26"><span class="calibre17"><span class="bold"><span>Figure c. HC, HCT, AC, and ACT can directly drive TTL, HC, HCT, AC, ACT, and 74C/4000B (5 V).</span></span></span></div>
<div class="calibre26"><span class="calibre17"><span class="bold"><span>Figure d. When 74C/4000(B) uses a supply voltage that is higher than +5 V, a level-shifting buffer IC, like the 4050B, can be used. The 4050B is powered by a 5-V supply and can accept 0-V/15-V logic levels at its inputs, while providing corresponding 0V/5V logic level outputs. The buffer also provides increased output drive current (4000B has a weak output drive capability when compared to TTL).</span></span></span></div>
<div class="calibre26"><span class="calibre17"><span class="bold"><span>Figure e. Recall that the actual high output of a TTL gate is around 3.4 <span class="italic">V</span> instead of 5 V. But CMOS (<span class="italic">V<sub class="calibre37"><small class="calibre28"><span class="calibre17">DD</span></small></sub></span> = 5 <span class="italic">V</span>) inputs may require from 4.4 (HC) to 4.9 <span class="italic">V</span> (4000B) for high input levels. If the CMOS device is of the 74C/4000B series, the actual required high input voltage depends on the supply voltage and is equal to <span class="italic"><sup class="calibre29"><small class="calibre28"><span class="calibre17">2</span></small></sup>/<sub class="calibre37"><small class="calibre28"><span class="calibre17">3</span></small></sub>V<sub class="calibre37"><small class="calibre28"><span class="calibre17">DD</span></small></sub></span>. To provide enough voltage to match voltage levels, a pullup resistor is used. The pullup resistor pulls the input to the CMOS gate up to the supply voltage to which the pullup resistor is connected.</span></span></span></div>
<div class="calibre26"><span class="calibre17"><span class="bold"><span>Figure f. Another trick for interfacing TTL with CMOS is to simply use a CMOS TTL-compatible gate, like the 74HCT or 74ACT.</span></span></span></div>
<div class="calibre26"><span class="calibre17"><span class="bold"><span>Figures g and h. These two figures show different methods for interfacing a TTL gate with a CMOS gate set to a higher supply voltage. In Figure g, a 4504B level-shifting buffer is used. The 4504B requires two supply voltages: a TTL supply (for 0/5 <span class="italic">V</span> levels) and a CMOS supply (for 0 to 15 <span class="italic">V</span> levels). In Figure h, an open-collector buffer and 10-k pullup resistor are used to convert the lower-level TTL output voltages into higher-level CMOS input voltages.</span></span></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.66</span></span></span></div><div class="calibre35"> </div>
<div id="filepos2786270" class="calibre3"><span class="calibre7"><span><span class="bold">12.5   Powering and Testing Logic ICs</span></span></span></div>
<div class="calibre11"><span><img alt="image" src="images/00007.jpg" class="calibre36"/></span></div>
<div class="calibre11"><span>Most TTL and CMOS logic devices will work with 5 <span class="italic">V</span> ± 0.25 <span class="italic">V</span> (5 percent) supplies like the ones shown in <a href="#filepos2787272">Fig. 12.67</a>. The battery supplies should be avoided when using certain TTL families like the 74<span class="italic">xx</span>, 74S, 74AS, and 74F, which dissipate considerably more current than, say, the CMOS 74HC series. Of course, the low-power, low-voltage 74LV, 74LVC, 74LVT, 74ALVC, and 74BCT series, which require from 1.2 to 3.6 <span class="italic">V</span> with as low as 2.5 μW/gate power dissipation (for 74BCT), are ideal for small battery-powered applications.</span></div>
<div id="filepos2787272" class="calibre3"><span><img alt="image" src="images/01751.jpg" class="calibre1453"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.67</span></span></span></div><div class="calibre35"> </div>
<div id="filepos2787548" class="calibre3"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.5.1   Power Supply Decoupling</span></span></span></span></span></div>
<div class="calibre11"><span>When a TTL device makes a low-to-high or a high-to-low level transition, there is an interval during which the conduction times in the upper and lower totem-pole output transistors overlap. During this interval, a drastic change in power supply current occurs, which results in a sharp, high-frequency current spike within the supply line. If a number of other devices are linked to the same supply, the unwanted spike can cause false triggering of these devices. The spike also can generate unwanted electromagnetic radiation.</span></div>
<div class="calibre26"><span>To avoid unwanted spikes within TTL systems, decoupling capacitors can be used. A decoupling capacitor, typically multilayer ceramic, from 0.01 to 0.1 μF (&gt;5 V), is placed directly across the <span class="italic">V<sub class="calibre37"><small class="calibre28"><span class="calibre17">CC</span></small></sub></span>-to-ground pins of each IC in the system. The capacitors absorb the spikes and keep the <span class="italic">V<sub class="calibre37"><small class="calibre28"><span class="calibre17">CC</span></small></sub></span> level at each IC constant, thus reducing the likelihood of false triggering and generally electromagnetic radiation. Decoupling capacitors should be placed as close to the ICs as possible to keep current spikes local, instead of allowing them to propagate back toward the power supply. You can usually get by with using one decoupling capacitor for every five to ten gates or one for every five counter or register ICs.</span></div>
<div id="filepos2789248" class="calibre48"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.5.2   Unused Inputs</span></span></span></span></span></div>
<div class="calibre11"><span><a></a>Unused inputs that affect the logical state of a chip should not be allowed to float. Instead, they should be tied high or low, as necessary (floating inputs are liable to pick up external electrical noise, which leads to erratic output behavior). For example, a four-input NAND TTL gate that uses only two inputs should have its two unused inputs held high to maintain proper logic operation. A three-input NOR gate that uses only two inputs should have its unused input held low to maintain proper logic operation. Likewise, the CLEAR and PRESET inputs of a flip-flop should be grounded or tied high, as appropriate.</span></div>
<div class="calibre26"><span>If there are unused sections within an IC (for example, unused logic gates within a multigate package), the inputs that link to these sections can be left unconnected for TTL but not for CMOS. When unused inputs are left unconnected in CMOS devices, the inputs may pick up unwanted charge and may reach a voltage level that causes output MOS transistors to conduct simultaneously, resulting in a large internal current spike from the supply (<span class="italic">V<sub class="calibre37"><small class="calibre28"><span class="calibre17">DD</span></small></sub></span>) to ground. The result can lead to excessive supply current drain and IC damage. To avoid this fate, inputs of unused sections of a CMOS IC should be grounded. <a href="#filepos2790988">Figure 12.68</a> illustrates what to do with unused inputs for TTL and CMOS NAND and NOR ICs.</span></div>
<div id="filepos2790988" class="calibre3"><span><img alt="image" src="images/01752.jpg" class="calibre183"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.68</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>As a last note of caution, never drive CMOS inputs when the IC’s supply voltage is removed. Doing so can damage the IC’s input protection diodes.</span></div>
<div id="filepos2791513" class="calibre48"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.5.3   Logic Probes and Logic Pulsers</span></span></span></span></span></div>
<div class="calibre11"><span>Two simple tools used to test logic ICs and circuits include the test probe and logic pulser, as shown in <a href="#filepos2791921">Fig. 12.69</a>.</span></div>
<div id="filepos2791921" class="calibre3"><span><img alt="image" src="images/01753.jpg" class="calibre1454"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.69</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>A typical logic probe comes in a pen-like package, with metal probe tip and power supply wires: one red and one black. Red is connected to the positive supply voltage of the digital circuit (<span class="italic">V<sub class="calibre37"><small class="calibre28"><span class="calibre17">CC</span></small></sub></span>), and black is connected to the ground (<span class="italic">V<sub class="calibre37"><small class="calibre28"><span class="calibre17">SS</span></small></sub></span>) of the circuit. To test a logic state within a circuit, the metal tip of the probe is applied. If a high voltage is detected, the probe’s high LED lights up; if a low voltage is detected, the probe’s low LED turns off.</span></div>
<div class="calibre26"><span><a></a>Along with performing simple static tests, logic probes can perform a few simple dynamic tests, such as detecting a single momentary pulse that is too fast for the human eye to detect or detecting a pulse train, such as a clock signal. To detect a single pulse, the probe’s PULSE/MEMORY switch is thrown to the MEMORY position. When a single pulse is detected, the internal memory circuit remembers the single pulse and lights up both the HI LED and PULSE LED at the same time. To clear the memory to detect a new single pulse, the PULSE/MEMORY switch is toggled. To detect a pulse train, the PULSE/MEMORY switch is thrown to the PULSE position. When a pulse train is detected, the PULSE LED flashes on and off.</span></div>
<div class="calibre26"><span>Logic probes usually will detect single pulses with widths as narrow as 10 ns and will detect pulse trains with frequencies around 100 MHz. Check the specifications that come with your probe to determine these minimum and maximum limits.</span></div>
<div class="calibre26"><span>A logic pulser allows you to send a single logic pulse or a pulse train through an IC and circuits, where the results of the applied pulses can be monitored by a logic probe. Like a logic probe, the pulser comes with similar supply leads. To send a single pulse, the SINGLE-PULSE/PULSE-TRAIN switch is set to SINGLE-PULSE, and then the SINGLE-PULSE button is pressed. To send a pulse train, switch to PULSE-TRAIN mode. With the pulser model shown in <a href="#filepos2791921">Fig. 12.69</a>, you get to select either 1 pulse per second (pps) or 500 pps.</span></div>
<div id="filepos2794653" class="calibre3"><span class="calibre7"><span><span class="bold">12.6   Sequential Logic</span></span></span></div>
<div class="calibre11"><span><img alt="image" src="images/00007.jpg" class="calibre36"/></span></div>
<div class="calibre11"><span>The combinational circuits covered previously (encoders, decoders, multiplexers, parity generators/checkers, and so on) have the property of input-to-output immediacy. This means that when input data is applied to a combinational circuit, the output responds almost immediately. Now, combinational circuits lack a very important characteristic: they cannot store information. A digital device that cannot store information is not very interesting, practically speaking.</span></div>
<div class="calibre26"><span><a></a>To provide “memory” to circuits, you must create devices that can latch onto data at a desired moment in time. The realm of digital electronics devoted to this subject is referred to as <span class="italic">sequential logic</span>. This branch of electronics is referred to as <span class="italic">sequential</span> because for data bits to be stored and retrieved, a series of steps must occur in a particular order. For example, a typical set of steps might involve first sending an enable pulse to a storage device, and then loading a group of data bits all at once (parallel load), or perhaps loading a group of data bits in a serial manner, which takes a number of individual steps. At a later time, the data bits may need to be retrieved by first applying a control pulse to the storage device. A series of other pulses might be required to force the bits out of the storage device.</span></div>
<div class="calibre26"><span>To push bits through sequential circuits usually requires a clock generator. The clock generator is similar to the human heart. It generates a series of high and low voltages (analogous to a series of high and low pressures as the heart pumps blood) that can set bits into action. The clock also acts as a time base on which all sequential actions can be referenced. Clock generators will be discussed in detail in <a href="CR%21QKYKJ7KY3158K36EJE0G9AYNF2ZW_split_018.html#filepos2844304">Section 12.6.7</a>. Now, let’s take a look at the most elementary of sequential devices: the SR flip-flop.</span></div>
<div id="filepos2797119" class="calibre48"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.6.1   SR Flip-Flops</span></span></span></span></span></div>
<div class="calibre11"><span>The most elementary data-storage circuit is the <span class="italic">set-reset</span> (SR) <span class="italic">flip-flop</span>, also referred to as a <span class="italic">transparent latch</span>. There are two basic kinds of SR flip-flops: the cross-NOR SR flip-flop and the cross-NAND SR flip-flop.</span></div>
<div class="calibre26"><span>Consider the cross-NOR SR flip-flop shown in <a href="#filepos2798744">Fig. 12.70</a>. At first, it appears that figuring out what the cross-NOR SR flip-flop does given only two input voltages is impossible, since the NOR gates’ inputs depend on the outputs, and what are the outputs anyway? (For now, pretend that <span class="italic">Q</span> and <img alt="image" src="images/01754.jpg" class="calibre1518"/> are not complements but separate variables; you could call them <span class="italic">X</span> and <span class="italic">Y</span> if you like.) Well, first of all, you know that a NOR gate will output a high (logic 1) only if both inputs are low (logic 0). From this, you can deduce that if <span class="italic">S</span> = 1 and <span class="italic">R</span> = 0, <span class="italic">Q</span> must be 1 and <img alt="image" src="images/01754.jpg" class="calibre1518"/> must be 0, regardless of the outputs. This is called the <span class="italic">set condition</span>. Likewise, by similar argument, we can deduce that if <span class="italic">S</span> = 0 and <span class="italic">R</span> = 1, <span class="italic">Q</span> must be 0 and <img alt="image" src="images/01754.jpg" class="calibre1518"/> must be 1. This is called the <span class="italic">reset condition</span>.</span></div>
<div id="filepos2798744" class="calibre3"><span><img alt="image" src="images/01755.jpg" class="calibre312"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.70</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span><a></a>But now, what about <span class="italic">R</span> = 0 and <span class="italic">S</span> = 0? Can you predict the outputs given only input levels? No! It is impossible to predict the outputs because the outputs are essential for predicting the outputs—it is a “catch-22.” However, if you know the states of the outputs beforehand, you can figure things out. For example, if you first set the flip-flop (<span class="italic">S</span> = 1, <span class="italic">R</span> = 0, <span class="italic">Q</span> = 1, <img alt="image" src="images/01754.jpg" class="calibre1518"/> = 0), and then apply <span class="italic">S</span> = 0, <span class="italic">R</span> = 0, the flip-flop would remain set (upper gate: <span class="italic">S</span> = 0, <span class="italic">Q</span> = 1 → <img alt="image" src="images/01754.jpg" class="calibre1518"/> =0; lower gate: <span class="italic">R</span> = 0, <img alt="image" src="images/01754.jpg" class="calibre1518"/> = 0 → <span class="italic">Q</span> = 1). Likewise, if you start out in reset mode (<span class="italic">S</span> = 0, <span class="italic">R</span> = 1, <span class="italic">Q</span> = 0, <span class="italic">Q</span> =0), and then apply <span class="italic">S</span> = 0, <span class="italic">R</span> = 0, the flip-flop remains in reset mode (upper gate: <span class="italic">S</span> = 0, <span class="italic">Q</span> = 0 → <img alt="image" src="images/01754.jpg" class="calibre1518"/> = 1; lower gate: <span class="italic">R</span> = 0, <img alt="image" src="images/01754.jpg" class="calibre1518"/> =1 → <span class="italic">Q</span> = 0). In other words, the flip-flop remembers, or latches onto, the previous output state even when both inputs go low (0). This is referred to as the <span class="italic">hold</span> condition.</span></div>
<div class="calibre26"><span>The last choice you have is <span class="italic">S</span> = 1, <span class="italic">R</span> = 1. Here, it is easy to predict what will happen because you know that as long as there is at least one high (1) applied to the input to the NOR gate, the output will always be 0. Therefore, <span class="italic">Q</span> = 0 and <img alt="image" src="images/01754.jpg" class="calibre1518"/> = 0. Now, there are two fundamental problems with the <span class="italic">S</span> = 1, <span class="italic">R</span> = 1 state. First, why would you want to set and reset at the same time? Second, when you return to the hold condition from <span class="italic">S</span> = 1, <span class="italic">R</span> = 1, you get an unpredictable result, unless you know which input returned low last. Why? When the inputs are brought back to the hold position (<span class="italic">R</span> = 0, <span class="italic">S</span> = 0, <span class="italic">Q</span> = 0, <img alt="image" src="images/01754.jpg" class="calibre1518"/> = 0), both NOR gates will want to be 1 (they want to be held). But let’s say one of the NOR gate’s outputs changes to 1 a fraction of a second before the other. In this case, the slower flip-flop will not output a 1 as planned, but will instead output 0. This is a classic example of a <span class="italic">race condition</span>, where the slower gate loses. But which flip-flop is the slower one? This unstable, unpredictable state cannot be avoided and is simply not used.</span></div>
<div class="calibre26"><span>The cross-NAND SR flip-flop provides the same basic function as the NOR SR flip-flop, but there is a fundamental difference: its hold and indeterminate states are reversed. This occurs because, unlike the NOR gate, which outputs a low only when both its inputs are the same, the NAND gate outputs a high only when both its inputs are the same. This means that the hold condition for the cross-NAND SR flip-flop is <span class="italic">S</span> = 1, <span class="italic">R</span> = 1, while the indeterminate condition is <span class="italic">S</span> = 0, <span class="italic">R</span> = 0.</span></div>
<div class="calibre26"><span>Now let’s look at two simple applications for SR flip-flops.</span></div>
<div class="calibre3"><span><span class="bold">Switch Debouncer</span></span></div>
<div class="calibre11"><span>Say you want to use the far-left switch/pullup resistor circuit (see <a href="#filepos2803188">Fig. 12.71</a>) to drive an AND gate’s input high or low (the other input is fixed high). When the switch is open, the AND gate should receive a high. When the switch is closed, the gate should receive a low. That’s what should happen, but that’s not what actually happens. Why? Because of switch bounce.</span></div>
<div id="filepos2803188" class="calibre3"><span><img alt="image" src="images/01756.jpg" class="calibre1519"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.71</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>When a switch is closed, the metal contacts bounce a number of times before coming to rest due to inherent springlike characteristics of the contacts. Though the bouncing typically lasts no more than 50 ms, the results can lead to unwanted false triggering, as shown in the far left circuit in <a href="#filepos2803188">Fig. 12.71</a>.</span></div>
<div class="calibre26"><span><a></a>A simple way to get rid of switch bounce is to use the switch debouncer circuit, shown at center of <a href="#filepos2803188">Fig. 12.71</a>. This circuit uses an SR flip-flop to store the initial switch contact voltage while ignoring all trailing bounces. In this circuit, when the switch is thrown from the <span class="italic">B</span> to <span class="italic">A</span> position, the flip-flop is set. As the switch bounces alternately high and low, the <span class="italic">Q</span> output remains high, because when the switch contact bounces away from <span class="italic">A</span>, the <span class="italic">S</span> input receives a low (<span class="italic">R</span> is low, too), but that’s just a hold condition; the output stays the same. The same debouncing feature occurs when the switch is thrown from position <span class="italic">A</span> to <span class="italic">B</span>.</span></div>
<div class="calibre3"><span><span class="bold">Latched Temperature or Light Alarm</span></span></div>
<div class="calibre11"><span>The simple circuit in <a href="#filepos2803188">Fig. 12.71</a> uses an SR flip-flop to sound a buzzer alarm when the temperature (when using a thermistor) or the light intensity (when using a photoresistor) reaches a critical level. When the temperature or light increases, the resistance of the thermistor or photoresistor decreases, and the <span class="italic">R</span> input voltage goes down. When the <span class="italic">R</span> input voltage goes below the high threshold level of the NAND gate, the flip-flop is set, and the alarm is sounded. The alarm will continue to sound until the RESET switch is pressed and the temperature or light level has gone below the critical triggering level. The pot is used to adjust this level.</span></div>
<div class="calibre3"><span><span class="bold">Level-Triggered SR Flip-Flop (the Beginning of Clocked Flip-Flops)</span></span></div>
<div class="calibre11"><span>Now it would be nice to make an SR flip-flop synchronous; that is, make the <span class="italic">S</span> and <span class="italic">R</span> inputs either enabled or disabled by a control pulse, such as a clock. Only when the clock pulse arrives are the inputs sampled. Flip-flops that respond in this manner are referred to as <span class="italic">synchronous</span> or <span class="italic">clocked flip-flops</span> (as opposed to the preceding asynchronous flip-flops).</span></div>
<div class="calibre26"><span>To make the preceding SR flip-flop into a synchronous or clocked device, simply attach enable gates to the inputs of the flip-flop, as shown in <a href="#filepos2806911">Fig. 12.72</a>. The figure shows the cross-NAND arrangement, but a cross-NOR arrangement also can be used. In this setup, only when the clock is high are the <span class="italic">S</span> and <span class="italic">R</span> inputs enabled. When the clock is low, the inputs are disabled, and the flip-flop is placed in hold mode. The truth table and timing diagram in <a href="#filepos2806911">Fig. 12.72</a> help illustrate how this device works.</span></div>
<div id="filepos2806911" class="calibre3"><span><img alt="image" src="images/01757.jpg" class="calibre1520"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.72</span></span></span></div><div class="calibre35"> </div>
<div class="calibre3"><span><a></a><span class="bold">Edge-Triggered SR Flip-Flops</span></span></div>
<div class="calibre11"><span>The level-triggered SR flip-flop has an annoying feature: its <span class="italic">S</span> and <span class="italic">R</span> inputs must be held at the desired input condition (set, reset, or no change) for the entire time that the clock signal is enabling the flip-flop. With a slight alteration, however, you can make the level-triggered flip-flop more flexible (in terms of timing control) by turning it into an edge-triggered flip-flop.</span></div>
<div class="calibre26"><span>An edge-triggered flip-flop samples the inputs only during either a positive or negative clock edge (↑ = positive edge, ↓ = negative edge). Any changes that occur before or after the clock edge are ignored—the flip-flop will be placed in hold mode.</span></div>
<div class="calibre26"><span>To make an edge-triggered flip-flop, introduce either a positive or a negative level-triggered clock pulse generator network into the previous level-triggered flip-flop, as shown in <a href="#filepos2808474">Fig. 12.73</a>.</span></div>
<div id="filepos2808474" class="calibre3"><span><img alt="image" src="images/01758.jpg" class="calibre528"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.73</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>In a positive edge-triggered generator circuit, a NOT gate with a propagation delay is added. Since the clock signal is delayed through the inverter, the output of the AND gate will not provide a low (as would be the case without a propagation delay), but will provide a pulse that begins at the positive edge of the clock signal and lasts for a duration equal to the propagation delay of the NOT gate. It is this pulse that is used to clock the flip-flop.</span></div>
<div class="calibre26"><span>Within the negative edge-triggered generator network, the clock signal is first inverted and then applied through the same NOT/AND network. The pulse begins at the negative edge of the clock and lasts for a duration equal to the propagation delay of the NOT gate. The propagation delay is typically so small (in nanoseconds) that the pulse is essentially an “edge.”</span></div>
<div class="calibre3"><span><span class="bold">Pulse-Triggered SR Flip-Flops</span></span></div>
<div class="calibre11"><span><a></a>A pulse-triggered SR flip-flop is a level-clocked flip-flop; however, for any change in output to occur, both the high and low levels of the clock must rise and fall. Pulse-triggered flip-flops are also called <span class="italic">master-slave flip-flops;</span> the master accepts the initial inputs and then “whips” the slave with its output when the negative clock edge arrives. Another analogy often used is to say that during the positive edge, the master gets cocked (like a gun), and during the negative clock edge, the slave gets triggered. <a href="#filepos2810626">Figure 12.74</a> shows a simplified pulse-triggered cross-NAND SR flip-flop.</span></div>
<div id="filepos2810626" class="calibre3"><span><img alt="image" src="images/01759.jpg" class="calibre109"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.74</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span>The master is simply a clocked SR flip-flop that is enabled during the high clock pulse and outputs <span class="italic">Y</span> and <img alt="image" src="images/01760.jpg" class="calibre1521"/> (set, reset, or no change). The slave is similar to the master, but it is enabled only during the negative clock pulse (due to the inverter). The moment the slave is enabled, it uses the <span class="italic">Y</span> and <img alt="image" src="images/01760.jpg" class="calibre1521"/> outputs of the master as inputs, and then outputs the final result.</span></div>
<div class="calibre26"><span>Notice the preset (<img alt="image" src="images/01761.jpg" class="calibre1522"/>) and clear (<img alt="image" src="images/01762.jpg" class="calibre1523"/>) inputs. These are called <span class="italic">asynchronous inputs</span>. Unlike the synchronous inputs, <span class="italic">S</span> and <span class="italic">R</span>, the asynchronous inputs disregard the clock and either clear (also called <span class="italic">asynchronous</span> reset) or preset (also called <span class="italic">asynchronous set</span>) the flip-flop. When - <img alt="image" src="images/01762.jpg" class="calibre1523"/> is high and <img alt="image" src="images/01761.jpg" class="calibre1522"/> is low, you get asynchronous reset, <span class="italic">Q</span> = 1, <img alt="image" src="images/01754.jpg" class="calibre1518"/> = 0, regardless of the <span class="italic">CLK, S</span>, and <span class="italic">R</span> inputs. These active-low inputs are therefore normally pulled high to make them inactive. The ability to apply asynchronous set and resets is often used to clear entire registers that consist of an array of flip-flops.</span></div>
<div class="calibre3"><span><span class="bold">General Rules for Deciphering Flip-Flop Logic Symbols</span></span></div>
<div class="calibre11"><span>Typically, you do not need to worry about constructing flip-flops from scratch. Instead, you buy flip-flop ICs, as discussed in the next section. Likewise, you do not need to worry about complex logic gate schematics. Instead, you use symbolic representations like the ones shown in <a href="#filepos2813257">Fig. 12.75</a>. Although the symbols in the figure apply to SR flip-flops, the basic rules that are outlined can be applied to the D and JK flip-flops, which are discussed in the following sections.</span></div>
<div id="filepos2813257" class="calibre3"><span><img alt="image" src="images/01763.jpg" class="calibre886"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.75</span></span></span></div><div class="calibre35"> </div>
<div id="filepos2813533" class="calibre3"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.6.2   SR Flip-Flop ICs</span></span></span></span></span></div>
<div class="calibre11"><span><a href="#filepos2814066">Figure 12.76</a> shows a few sample SR flip-flop (latch) ICs. The 74LS279A contains four independent SR latches (note that two of the latches have an <span class="italic"><small class="calibre28"><span class="calibre17">EXTRA SET INPUT</span></small></span>). This IC is commonly used in switch debouncers.</span></div>
<div id="filepos2814066" class="calibre3"><span><img alt="image" src="images/01764.jpg" class="calibre230"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.76</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span><a></a>The 4043 contains four three-state cross-coupled NOR SR latches. Each latch has individual set and reset inputs, as well as separate <span class="italic">Q</span> outputs. The three-state feature is an extra bonus, which allows you to effectively disconnect all <span class="italic">Q</span> outputs, making it appear that the outputs are open circuits (high impedance, or high <span class="italic">Z</span>). This three-state feature is often used in applications where a number of devices must share a common data bus. When the output data from one latch is applied to the bus, the outputs of other latches (or other devices) are disconnected via the high-<span class="italic">Z</span> condition. The 4044 is similar to the 4043 but contains four three-state cross-coupled NAND RS latches.</span></div>
<div id="filepos2815146" class="calibre48"><span class="bold"><span class="italic"><span><span class="bold"><span class="italic">12.6.3   D-Type Flip-Flops</span></span></span></span></span></div>
<div class="calibre11"><span>A D-type flip-flop (data flip-flop) is a single input device. It is basically an SR flip-flop, where <span class="italic">S</span> is replaced with <span class="italic">D</span> and <span class="italic">R</span> is replaced with <img alt="image" src="images/01682.jpg" class="calibre1498"/> (inverted <span class="italic">D</span>). The inverted input is tapped from the <span class="italic">D</span> input through an inverter to the <span class="italic">R</span> input, as shown in <a href="#filepos2816159">Fig. 12.77</a>. The inverter ensures that the indeterminate condition (race, or not used state, <span class="italic">S</span> = 1, <span class="italic">R</span> = 1) never occurs. At the same time, the inverter eliminates the hold condition so that you are left with only set (<span class="italic">D</span> = 1) and reset (<span class="italic">D</span> = 0) conditions. The circuit in <a href="#filepos2816159">Fig. 12.77</a> represents a level-triggered D-type flip-flop.</span></div>
<div id="filepos2816159" class="calibre3"><span><img alt="image" src="images/01765.jpg" class="calibre333"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.77</span></span></span></div><div class="calibre35"> </div>
<div class="calibre26"><span><a></a>To create a clocked D-type level-triggered flip-flop, first start with the clocked level-triggered SR flip-flop and throw in the inverter, as shown in <a href="#filepos2816721">Fig. 12.78</a>.</span></div>
<div id="filepos2816721" class="calibre3"><span><img alt="image" src="images/01766.jpg" class="calibre365"/></span></div>
<div class="calibre34"><span class="calibre17"><span class="bold"><span>FIGURE 12.78</span></span></span></div></body></html>
