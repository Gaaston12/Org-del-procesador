<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Code: The Hidden Language of Computer Hardware and Software</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="filepos1727052" style="height:0pt"></div><div id="filepos1727052" class="calibre_">
<div class="calibre_">
<div class="calibre_">
<div class="calibre_">
<h1 class="calibre1" id="calibre_pb_79"><span class="calibre2"><a shape="rect" class="calibre4"></a>Chapter 24. Languages High and Low </span></h1>
</div>
</div>
</div>
<p class="calibre_1"><a shape="rect"></a>Programming in machine code is like eating with a toothpick. The bites are so small and the process so laborious that dinner takes forever. Likewise, the bytes of machine code perform the tiniest and simplest of imaginable computing tasks—loading a number from memory into the processor, adding it to another, storing the result back to memory—so that it's difficult to imagine how they contribute to an entire meal. </p>
<p class="calibre_1">We have at least progressed from that primitive era at the beginning of <a shape="rect" href="index_split_025.html#filepos1600607">Chapter 22</a>, in which we were using switches on a control panel to enter binary data into memory. In that chapter, we discovered how we could write simple programs that let us use the <a shape="rect"></a>keyboard and the <a shape="rect"></a>video display to enter and examine <a shape="rect"></a>hexadecimal bytes of machine code. This was certainly better, but it's not the last word in improvements. </p>
<p class="calibre_1">As you know, the bytes of machine code are associated with certain short <a shape="rect"></a>mnemonics, such as <span><em class="italic">MOV</em></span>, <span><em class="italic">ADD</em></span>, <span><em class="italic">CALL</em></span>, and <span><em class="italic">HLT</em></span>, that let us refer to the machine code in something vaguely resembling English. These mnemonics are often written with operands that further indicate what the machine-code instruction does. For example, the 8080 machine-code byte 46h causes the microprocessor to move into register B the byte stored at the memory address referenced by the 16-bit value in the register pair HL. This is more concisely written as </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">MOV B,[HL]</tt></div></div><p class="calibre_1">Of course, it's much easier to write programs in assembly language than in machine code, but the microprocessor can't understand assembly language. I've explained how you'd write assembly-language programs on paper. Only when you thought you were ready to run an assembly-language program on the microprocessor would you hand-assemble it, which means that you'd convert the assembly-language statements to machine-code bytes and enter them into memory. </p>
<p class="calibre_1">What's even better is for the computer to do this conversion for you. If you were running the CP/M operating system on your 8080 computer, you'd already have all the tools you need. Here's how it works. </p>
<p class="calibre_1">First you create a text file to contain your program written in assembly language. You can use the CP/M program ED.COM for this job. This program is a text editor, which means that it allows you to create and modify text files. Let's suppose you create a text file with the name PROGRAM1.ASM. The ASM file type indicates that this file contains an assembly-language program. The file might look something like this: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">      ORG 0100h<br class="calibre30"/>      LXI DE, Text<br class="calibre30"/>      MVI C,9<br class="calibre30"/>      CALL 5<br class="calibre30"/>      RET<br class="calibre30"/>Text: DB 'Hello!$'<br class="calibre30"/>      END</tt></div></div><p class="calibre_1">This file has a couple of statements we haven't seen before. The first one is an <span><em class="italic">ORG</em></span> (for <span><em class="italic">origin</em></span>) statement. This statement does <span><em class="italic">not</em></span> correspond to an 8080 instruction. Instead, it indicates that the address of the next statement is to begin at address 0100h, which you'll recall is the address where CP/M loads programs into memory. </p>
<p class="calibre_1">The next statement is an <span><em class="italic">LXI</em></span> (<span><em class="italic">Load Extended Immediate</em></span>) instruction, which loads a 16-bit value into the register pair DE. In this case, that 16-bit value is given as the label <span><em class="italic">Text</em></span>. That label is located near the bottom of the program in front of a <span><em class="italic">DB</em></span> (<span><em class="italic">Data Byte</em></span>) statement, something else we haven't seen before. The <span><em class="italic">DB</em></span> statement can be followed by several bytes separated by commas or (as I do here) by some text in single quotation marks. </p>
<p class="calibre_1">The <span><em class="italic">MVI</em></span> (<span><em class="italic">Move Immediate</em></span>) statement moves the value 9 into register C. The <span><em class="italic">CALL 5</em></span> statement makes a CP/M function call. Function 9 means to display a string of characters beginning at the address given by the DE register pair and stop when a dollar sign is encountered. (You'll notice that the text in the last line of the program ends with a dollar sign. The use of a dollar sign to signify the end of a character string is quite odd, but that's the way CP/M happens to work.) The final <span><em class="italic">RET</em></span> statement ends the program and returns control to CP/M. (That's actually one of several ways to end a CP/M program.) The <span><em class="italic">END</em></span> statement indicates the end of the assembly-language file. </p>
<p class="calibre_1">So we have a text file containing seven lines of text. The next step is to assemble it, which means to convert it to machine code. Previously we've done this by hand. But since we're running CP/M, we can use a program included with CP/M named ASM.COM. This is the CP/M <span><em class="italic">assembler</em></span>. We run ASM.COM from the CP/M command line this way: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">ASM PROGRAM1.ASM</tt></div></div><p class="calibre_1">The ASM program looks at the file PROGRAM1.ASM and creates a new file named PROGRAM1.COM that contains the machine code corresponding to the assembly-language statements that we wrote. (Actually there's another step in the process, but it's not important in this account of what happens.) Now you can run PROGRAM1.COM from the CP/M command line. It displays the text "Hello!" and then ends. </p>
<p class="calibre_1">The PROGRAM1.COM file contains the following 16 bytes:</p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">11 09 01 OE 09 CD 05 00 C9 48 65 6C 6C 6F 21 24</tt></div></div><p class="calibre_1">The first 3 bytes are the <span><em class="italic">LXI</em></span> instruction, the next 2 the <span><em class="italic">MVI</em></span> instruction, the next 3 the <span><em class="italic">CALL</em></span> instruction, and the next the <span><em class="italic">RET</em></span> instruction. The last 7 bytes are the ASCII characters for the five letters of "Hello," the exclamation point, and the dollar sign. </p>
<p class="calibre_1">What an assembler such as ASM.COM does is read an assembly-language program (often called a <span><em class="italic">source-code</em></span> file) and write out a file containing machine code—an <span><em class="italic">executable</em></span> file. In the grand scheme of things, assemblers are fairly simple programs because there's a one-to-one correspondence between the assembly-language mnemonics and machine code. The assembler works by separating each line of text into mnemonics and arguments and then comparing these small words and letters with a list that the assembler contains of <span><em class="italic">all</em></span> the possible mnemonics and arguments. These comparisons reveal which machine-code instructions correspond to each statement. </p>
<p class="calibre_1">Notice how the assembler figures out that the <span><em class="italic">LXI</em></span> instruction must set the register pair DE to the address 0109h. If the <span><em class="italic">LXI</em></span> instruction itself is located at 0100h (as it is when CP/M loads the program into memory to run), address 0109h is where the text string begins. Generally a programmer using an assembler doesn't need to worry about the specific addresses associated with different parts of the program. </p>
<p class="calibre_1">The first person to write the first assembler had to hand-assemble the program, of course. A person who writes a new (perhaps improved) assembler for the same computer can write it in assembly language and then use the first assembler to assemble it. Once the new assembler is assembled, it can assemble itself. </p>
<p class="calibre_1">Every time a new microprocessor comes out, a new assembler is needed. The new assembler, however, can first be written on an existing computer using that computer's assembler. This is called a <span><em class="italic">cross-assembler</em></span>. The assembler runs on Computer A but creates code that runs on Computer B. </p>
<p class="calibre_1">Although an assembler eliminates the less-creative aspects of assembly-language <a shape="rect"></a>programming (the hand-assembling part), assembly language still has two major problems. The first problem (which you've perhaps already surmised) is that it can be very tedious. You're working down on the level of the microprocessor chip, and you have to worry about every little thing. </p>
<p class="calibre_1">The second problem is that assembly language isn't <span><em class="italic">portable</em></span>. If you write an assembly-language program for the Intel 8080, it's not suitable for the Motorola 6800. You must rewrite the program in 6800 assembly language. This probably won't be as difficult as writing the original program because you've already solved the major organizational and algorithmic problems. But it's still a lot of work. </p>
<p class="calibre_1">I explained in the last chapter how modern microprocessors have built-in machine-code instructions that do floating-point arithmetic. This is certainly convenient, but it doesn't go quite far enough. It would be preferable to abandon entirely those processor-dependent machine-code instructions that perform individual rudimentary arithmetic operations, and instead express multiple mathematical operations using a time-honored algebraic notation. Here's an example: </p>
<table border="0" summary="Simple list" class="calibre13"><span class="calibre23">
<tr class="calibre17">
<td rowspan="1" colspan="1" border="1" class="calibre20"><span class="calibre24">A x Sin (2 x PI + B) / C</span></td>
</tr>
</span></table>
<p class="calibre_1">where A, B, and C are numbers and PI is equal to 3.14159.</p>
<p class="calibre_1">Well, why not? If such a statement were in a text file, it should be possible to write an assembly-language program that reads the text file and converts the algebraic expression to machine code. </p>
<p class="calibre_1">If you needed to calculate such an algebraic expression only once, you could do it by hand or with a calculator. It's likely you're considering a computer solution because you need to calculate that expression with many different values of A, B, and C. For this reason, the algebraic expression will probably not appear in isolation. You should also consider some kind of context for the expression that allows it to be evaluated for different values. </p>
<p class="calibre_1">What you're on the verge of creating here is known as a <span><em class="italic">high-level</em></span> programming language. Assembly language is considered a <span><em class="italic">low-level</em></span> language because it's very close to the hardware of the computer. Although the term <span><em class="italic">high-level</em></span> is used to describe any programming language other than assembly language, some languages are considered to be higher level than others. If you were the president of a company and you could sit at your computer and type in (or better yet, just prop your feet up and dictate), "Calculate all the profits and losses for this year, write up an annual report, print off a couple thousand copies, and send them to all our stockholders," you would be working with a very high-level language indeed! In the real world, programming languages don't come anywhere close to that ideal.<a shape="rect"></a></p>
<p class="calibre_1">Human languages are usually the result of hundreds and thousands of years of complex influences, random changes, and adaptations. Even artificial languages such as Esperanto betray their origins in real language. High-level computer languages are, however, more deliberate conceptions. The challenge of inventing a programming language is quite appealing to some people because the language defines how a person conveys instructions to the computer. It was estimated in 1993 that there had been over 1000 high-level languages invented and implemented since the beginning of the 1950s. </p>
<p class="calibre_1">Of course, it's not enough to simply <span><em class="italic">define</em></span> a high-level language (which involves developing a <span><em class="italic">syntax</em></span> to express all the things you want to do with the language); you must also write a <span><em class="italic">compiler</em></span>, which is the program that converts the statements of your high-level language to machine code. Like an assembler, a compiler must read through a source-code file character by character and break it down into short words and symbols and numbers. A compiler, however, is much more complex than an assembler. An assembler is simplified somewhat because of the one-to-one correspondence between assembly-language statements and machine code. A compiler usually must translate a single statement of a high-level language into many machine-code instructions. Compilers aren't easy to write. Whole books are devoted to their design and construction. </p>
<p class="calibre_1">High-level languages have advantages and disadvantages. A primary advantage is that high-level languages are usually easier to learn and to program in than assembly languages. Programs written in high-level languages are often clearer and more concise. High-level languages are often portable—that is, they aren't dependent on a particular processor as are assembly languages. Thus, they let a programmer work without knowing about the underlying structure of the machine on which the program will be running. Of course, if you need to run the program on more than one processor, you need compilers that generate machine code for those processors. The actual executable files are still specific to individual processors. </p>
<p class="calibre_1">On the other hand, it's almost always the case that a good assembly-language programmer can write better code than a compiler can. What this means is that an executable produced from a program written in a high-level language will be larger and slower than a functionally identical program written in assembly language. (In recent years, however, this has become less obvious as microprocessors have become more complex and compilers have also become more sophisticated in optimizing code.) </p>
<p class="calibre_1">Also, although a high-level language might make a processor easy to use, it doesn't make it more powerful. Anything that a processor is capable of you can exploit in assembly language. Because a high-level language must be translated into machine code, a high-level language can only reduce the capabilities of a processor. Indeed, if a high-level language is truly portable, it can't use features specific to certain processors. </p>
<p class="calibre_1">An example: Many processors have bit-shifting instructions. As you'll recall, these instructions shift the bits of the accumulator to the right or left. But almost no high-level programming languages include such operations. If you have a programming job that could use bit shifting, you'll have to mimic it by multiplying or dividing by 2. (Not that this is bad: Indeed, many modern compilers use a processor's bit-shifting instructions to implement multiplication or division by powers of two.) Many languages also don't include Boolean operations on bits. </p>
<p class="calibre_1">In the early days of home computers, most application programs were written in assembly language. These days, however, assembly language is rarely used except for special purposes. As hardware has been added to processors that implements pipelining—the progressive execution of several instruction codes simultaneously—assembly language has become trickier and more difficult. At the same time, compilers have become more sophisticated. The larger storage and memory capacity of today's computers has also played a role in this trend: Programmers no longer feel the need to create code that runs in a small amount of memory and fits on a small diskette. </p>
<p class="calibre_1">Although designers of many early computers attempted to formulate problems for them in algebraic notation, the first real working compiler is generally considered to be the A-0 for the <a shape="rect"></a>UNIVAC created by Grace Murray <a shape="rect"></a>Hopper (1906–1992) at <a shape="rect"></a>Remington-Rand in 1952. Dr. Hopper got an early start with computers when she worked for Howard <a shape="rect"></a>Aiken on the Mark I in 1944. In her eighties, she was still working in the computer industry doing public relations for <a shape="rect"></a>Digital Equipment Corporation (DEC). </p>
<p class="calibre_1">The oldest high-level language still in use today (although extensively revised over the years) is <a shape="rect"></a>FORTRAN. Many computer languages have made-up names that are written in uppercase because they're acronyms of sorts. FORTRAN is a combination of the first three letters of FORmula and the first four letters of TRANslation. It was developed at IBM for the 704 series of computers in the mid-1950s. For many years, FORTRAN was considered the language of choice for scientists and engineers. It has very extensive floating-point support and even supports complex numbers (which, as I explained in the last chapter, are combinations of real and imaginary numbers). </p>
<p class="calibre_1">All programming languages have their defenders and detractors, and people can get passionate about their favorites. In an attempt to assume a neutral position, I've chosen a language to serve as an archetype for this account of programming concepts that almost no one uses anymore. Its name is ALGOL (which stands for ALGOrithmic Language, but ALGOL the language also shares its name with the second brightest star in the constellation Perseus). ALGOL is also appropriate for this exploration into the nature of high-level programming languages because it's in many ways a seminal language, the direct ancestor of many popular general-purpose languages of the past 40 years. Even today, people refer to "ALGOL-like" programming languages. </p>
<p class="calibre_1">The first version of the language, known as ALGOL 58, was designed by an international committee in 1957 and 1958. It was improved two years later in 1960, and the revised version was named ALGOL 60. Eventually, there was an ALGOL 68, but for this chapter I'll be using the version of ALGOL as described by the document "Revised Report on the Algorithmic Language ALGOL 60" finalized in 1962 and first published in 1963. </p>
<p class="calibre_1">Let's write some ALGOL code. We'll assume we have an ALGOL compiler named ALGOL.COM that runs under CP/M or perhaps MS-DOS. Our first ALGOL program is a text file named FIRST.ALG. Notice the ALG file type. </p>
<p class="calibre_1">An ALGOL program must be enclosed within the words <span><em class="italic">begin</em></span> and <span><em class="italic">end</em></span>. Here's a program that displays a line of text: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">begin<br class="calibre30"/>    print ('This is my fist ALGOL program!');<br class="calibre30"/>ende</tt></div></div><p class="calibre_1">You can run the ALGOL compiler by specifying the FIRST.ALG program like this:</p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">ALGOL FIRST.ALG</tt></div></div><p class="calibre_1">The ALGOL compiler will probably respond by displaying something similar to the following:</p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">Line 3: Unrecognized keyword 'ende'.</tt></div></div><p class="calibre_1">A compiler is pickier about spelling than an old-fashioned English teacher. I misspelled the word <span><em class="italic">end</em></span> when I was typing the program, so the compiler tells me that the program has a <span><em class="italic">syntax error</em></span>. At the time it encountered <span><em class="italic">ende</em></span>, it expected to find a <span><em class="italic">keyword</em></span>, which is a word that it recognizes. </p>
<p class="calibre_1">After fixing the problem, you can run the ALGOL compiler again. Sometimes a compiler will create an executable directly (named FIRST.COM, or perhaps FIRST.EXE under MS-DOS); sometimes you need to perform another step. Regardless, you'll soon be able to run the FIRST program from the command line: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">FIRST</tt></div></div><p class="calibre_1">The FIRST program responds by displaying</p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">This is my fist ALGOL program!</tt></div></div><p class="calibre_1">Oops! Another spelling error. This is one that the compiler could <span><em class="italic">not</em></span> be expected to find. For that reason it's called a <span><em class="italic">run-time error</em></span>—an error that's apparent only when you run the program. </p>
<p class="calibre_1">As is probably obvious, the <span><em class="italic">print</em></span> statement in our first ALGOL program displays something on the screen, in this case a line of text. (The program is thus the ALGOL equivalent of the CP/M assembly-language program shown earlier in this chapter.) The <span><em class="italic">print</em></span> statement isn't actually part of the official specification of the ALGOL language, but I'm assuming that the particular ALGOL compiler we're using includes such a facility, sometimes called a <span><em class="italic">built-in function</em></span>. Most ALGOL statements (but not <span><em class="italic">begin</em></span> and <span><em class="italic">end</em></span>) must be followed by a semicolon. The indenting of the <span><em class="italic">print</em></span> statement isn't required, but indenting is often used to make the structure of the program clearer. </p>
<p class="calibre_1">Let's assume now that you want to write a program that multiplies two numbers. Every programming language includes the concepts of <span><em class="italic">variables</em></span>. In a program, a variable's name is a letter, a short sequence of letters, or even a short word. In reality, the variable corresponds to a memory location, but in the program it's referenced by means of a name, not a numeric memory address. This program has three variables named <span><em class="italic">a</em></span>, <span><em class="italic">b</em></span>, and <span><em class="italic">c</em></span>: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">begin<br class="calibre30"/>    real a, b, c;<br class="calibre30"/><br class="calibre30"/>    a := 535.43;<br class="calibre30"/>    b := 289.771;<br class="calibre30"/>    c := a x b;<br class="calibre30"/><br class="calibre30"/>    print ('The product of ', a, ' and ', b, ' is ', c);<br class="calibre30"/>end</tt></div></div><p class="calibre_1">The <span><em class="italic">real</em></span> statement is called a <span><em class="italic">declaration</em></span> statement. It indicates that you want to declare the presence of variables in your program. In this case, the variables are named <span><em class="italic">a</em></span>, <span><em class="italic">b</em></span>, and <span><em class="italic">c</em></span> and are real or floating-point numbers. (ALGOL also supports the keyword <span><em class="italic">integer</em></span> to declare integer variables.) Usually programming languages require that variable names begin with a letter. Variable names can also contain numbers, just as long as the first character is a letter, but they must not contain spaces or most other characters. Often compilers place limits on the length of a variable name. I'll just use single letters in the example in this chapter. </p>
<p class="calibre_1">If the particular ALGOL compiler we happen to be using supports the IEEE floating-point standard, the three variables in the program each require 4 bytes of storage (for single-precision numbers) or 8 bytes of storage (for double-precision numbers). </p>
<p class="calibre_1">The next three statements are <span><em class="italic">assignment</em></span> statements. In ALGOL, you can always recognize an assignment statement because it's designated by a colon followed by the equal sign. (In most computer languages, only the equal sign is required for an assignment statement.) On the left is a variable. On the right is an expression. The variable is set to the number that results from an evaluation of the expression. The first two assignment statements indicate that both <span><em class="italic">a</em></span> and <span><em class="italic">b</em></span> are assigned particular values. The third assignment statement in the program assigns the variable <span><em class="italic">c</em></span> to the product of variables <span><em class="italic">a</em></span> and <span><em class="italic">b</em></span>. </p>
<p class="calibre_1">These days, the familiar x multiplication symbol is usually not allowed in programming languages because it's not part of the ASCII and <a shape="rect"></a>EBCDIC character sets. Most programming languages use an asterisk to indicate multiplication. While ALGOL uses a slash (/) for division, the language also includes a division sign (÷) for integer division, which indicates how many times the divisor is contained in the dividend. ALGOL also defines an arrow (↑), another non-ASCII character, for exponentiation. </p>
<p class="calibre_1">Finally the <span><em class="italic">print</em></span> statement displays everything. It combines text and variables separated by commas. Displaying ASCII characters is probably not a major chore for the <span><em class="italic">print</em></span> statement, but here the function must also convert the floating-point numbers to ASCII: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">The product of 535.43 and 289.771 is 155152.08653</tt></div></div><p class="calibre_1">The program then terminates and returns control to the operating system.</p>
<p class="calibre_1">If you want to multiply a couple of other numbers, you'll need to edit the program, change the numbers, recompile it, and run it again. You can avoid this frequent recompiling by taking advantage of another built-in function named <span><em class="italic">read</em></span>. </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">begin<br class="calibre30"/>    real a, b, c;<br class="calibre30"/><br class="calibre30"/>    print ('Enter the first number: ');<br class="calibre30"/>    read (a);<br class="calibre30"/><br class="calibre30"/>    print ('Enter the second number: ');<br class="calibre30"/>    read (b);<br class="calibre30"/><br class="calibre30"/>    c := a x b;<br class="calibre30"/><br class="calibre30"/>    print ('The product of ', a, ' and ', b, ' is ', c);<br class="calibre30"/>end</tt></div></div><p class="calibre_1">The <span><em class="italic">read</em></span> statements read ASCII characters that you type at the keyboard and convert them to floating-point values. </p>
<p class="calibre_1">A very important construction in high-level languages is the <span><em class="italic">loop</em></span>. The loop allows you to write a program that does the same thing for many different values of a variable. Suppose you want to write a program that calculates the cubes of 3, 5, 7, and 9. You can do it like this: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">begin<br class="calibre30"/>    real a, b;<br class="calibre30"/><br class="calibre30"/>    for a := 3, 5, 7, 9 do<br class="calibre30"/>    begin<br class="calibre30"/>        b := a x a x a;<br class="calibre30"/>        print ('The cube of ', a, ' is ', b);<br class="calibre30"/>    end<br class="calibre30"/>end</tt></div></div><p class="calibre_1">The <span><em class="italic">for</em></span> statement sets the variable <span><em class="italic">a</em></span> first to the value 3 and then executes the statement that follows the <span><em class="italic">do</em></span> keyword. If there's more than one statement that must be executed (as is the case here), the multiple statements must be included between <span><em class="italic">begin</em></span> and <span><em class="italic">end</em></span> statements. These two keywords define a <span><em class="italic">block</em></span> of statements. The <span><em class="italic">for</em></span> statement then executes those same statements for the variable <span><em class="italic">a</em></span> set to 5, 7, and 9. </p>
<p class="calibre_1">Here's another version of the <span><em class="italic">for</em></span> statement. This one calculates the cubes of odd numbers from 3 through 99: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">begin<br class="calibre30"/>    real a, b;<br class="calibre30"/><br class="calibre30"/>    for a := 3 step 2 until 99 do<br class="calibre30"/>    begin<br class="calibre30"/>        b := a x a x a;<br class="calibre30"/>        print ('The cube of ', a, ' is ', b);<br class="calibre30"/>    end<br class="calibre30"/>end</tt></div></div><p class="calibre_1">The <span><em class="italic">for</em></span> statement initially sets the variable <span><em class="italic">a</em></span> to 3 and executes the block following the <span><em class="italic">for</em></span> statement. Then <span><em class="italic">a</em></span> is increased by the number following the <span><em class="italic">step</em></span> keyword, which is 2. The new value of <span><em class="italic">a</em></span>, which is 5, is used to execute the block. The variable <span><em class="italic">a</em></span> will continue to be increased by 2. When it exceeds 99, the <span><em class="italic">for</em></span> loop is completed. </p>
<p class="calibre_1">Programming languages usually have a very strict syntax. In Algol 60, for example, the keyword <span><em class="italic">for</em></span> can be followed by only one type of thing—a variable name. In English, however, the word <span><em class="italic">for</em></span> can be followed by all sorts of different words, such as <span><em class="italic">example</em></span> in the previous sentence. While compilers aren't simple programs to write, they're obviously much easier than programs that must interpret human languages. </p>
<p class="calibre_1">Another important feature of most programming languages is the <span><em class="italic">conditional</em></span>. This is a statement that causes another statement to execute only if a particular condition is true. Here's an example that uses the ALGOL built-in function <span><em class="italic">sqrt</em></span>, which calculates a square root. The <span><em class="italic">sqrt</em></span> function doesn't work for negative numbers, so this program avoids that occurrence: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">begin<br class="calibre30"/>    real a, b;<br class="calibre30"/><br class="calibre30"/>    print ('Enter a number: ');<br class="calibre30"/>    read (a);<br class="calibre30"/><br class="calibre30"/>    if a &lt; 0 then<br class="calibre30"/>        print ('Sorry, the number was negative.');<br class="calibre30"/>    else<br class="calibre30"/>        begin<br class="calibre30"/>            b = sqrt(a);<br class="calibre30"/>            print ('The square root of ', a, ' is ', b);<br class="calibre30"/>        end<br class="calibre30"/>end</tt></div></div><p class="calibre_1">The left angle bracket (&lt;) is a <span><em class="italic">less than</em></span> sign. If the user of this program types in a number that is less than 0, the first <span><em class="italic">print</em></span> statement is executed. If not—that is, if the number is greater than or equal to 0—the block containing the other <span><em class="italic">print</em></span> statement is executed. </p>
<p class="calibre_1">So far, the variables shown in the programs in this chapter store only one value each. Often it's convenient for the same variable to store many values. This is known as an <span><em class="italic">array</em></span>. An array is declared in an ALGOL program like this: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">real array a[1:100];</tt></div></div><p class="calibre_1">In this case, we've indicated that we want to use this variable to store 100 different floating-point values, called <span><em class="italic">elements</em></span> of the array. The first one is referenced by <span><em class="italic">a[1]</em></span>, the second by <span><em class="italic">a[2]</em></span>, and the last by <span><em class="italic">a[100</em></span>]. The number in brackets is called the <span><em class="italic">index</em></span> of the array. </p>
<p class="calibre_1">This program calculates all the square roots of 1 through 100 and stores them in an array. Then it prints them out:</p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">begin<br class="calibre30"/>    real array a[1:100];<br class="calibre30"/>    integer i;<br class="calibre30"/><br class="calibre30"/>    for i := 1 step 1 until 100 do<br class="calibre30"/>        a[i] := sqrt(i);<br class="calibre30"/><br class="calibre30"/>    for i := 1 step 1 until 100 do<br class="calibre30"/>        print ('The square root of ', i, ' is ', a[i]);<br class="calibre30"/>end</tt></div></div><p class="calibre_1">This program also shows an <span><em class="italic">integer</em></span> variable named <span><em class="italic">i</em></span> (which is a traditional name for an <span><em class="italic">integer</em></span> variable because it's the first letter of the word). In the first <span><em class="italic">for</em></span> loop, each element of the array is assigned the square root of its index. In the second <span><em class="italic">for</em></span> loop, these are printed out. </p>
<p class="calibre_1">In addition to <span><em class="italic">real</em></span> and <span><em class="italic">integer</em></span>, variables can also be declared as <span><em class="italic">Boolean</em></span>. (Remember George Boole from <a shape="rect" href="index_split_013.html#filepos427745">Chapter 10</a>?) A <span><em class="italic">Boolean</em></span> variable has only two possible values, which are <span><em class="italic">true</em></span> and <span><em class="italic">false</em></span>. I make use of a <span><em class="italic">Boolean</em></span> array (and almost every other feature we've learned about so far) in the final program of this chapter—a program that implements a famous algorithm for finding prime numbers called the <a shape="rect"></a>Sieve of Eratosthenes. Eratosthenes (circa 276–196 BCE) was the librarian of the legendary library at Alexandria and is best remembered today for accurately calculating the circumference of the earth.<a shape="rect"></a></p>
<p class="calibre_1">Prime numbers are those whole numbers that are divisible without a remainder only by themselves and 1. The first prime number is 2 (the only even prime number), and the primes continue with 3, 5, 7, 11, 13, 17, and so forth. </p>
<p class="calibre_1">Eratosthenes' technique begins with a list of the positive whole numbers beginning with 2. Because 2 is a prime number, cross out all the numbers that are multiples of 2. (That's all the even numbers except 2.) Those numbers aren't primes. Because 3 is a prime number, cross out all the numbers that are multiples of 3. We already know 4 isn't a prime number because it has been crossed out. The next prime is 5, so cross out all the multiples of 5. Continue in this way. What you have left are the prime numbers. </p>
<p class="calibre_1">An ALGOL program to determine all the prime numbers through 10,000 can implement this algorithm by declaring a <span><em class="italic">Boolean</em></span> array with indices from 2 through 10,000: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">begin<br class="calibre30"/>    Boolean array a[2:10000];<br class="calibre30"/>    integer i, j;<br class="calibre30"/><br class="calibre30"/>    for i := 2 step 1 until 10000 do<br class="calibre30"/>        a[i] := true;<br class="calibre30"/><br class="calibre30"/>    for i := 2 step 1 until 100 do<br class="calibre30"/>        if a[i] then<br class="calibre30"/>            for j := 2 step 1 until 10000 ÷ i do<br class="calibre30"/>                a[i x j] := false;<br class="calibre30"/><br class="calibre30"/>    for i := 2 step 1 until 10000 do<br class="calibre30"/>        if a[i] then<br class="calibre30"/>            print (i);<br class="calibre30"/>end</tt></div></div><p class="calibre_1">The first <span><em class="italic">for</em></span> loop sets all the array elements to the Boolean value <span><em class="italic">true</em></span>. Thus, the program starts by assuming that all the numbers are prime. The second <span><em class="italic">for</em></span> loop goes from 1 through 100 (the square root of 10,000). If the number is prime, which means that <span><em class="italic">a[i]</em></span> is true, another <span><em class="italic">for</em></span> loop sets all the multiples of that number to <span><em class="italic">false</em></span>. Those numbers aren't prime. The final <span><em class="italic">for</em></span> loop prints out all the prime numbers, which are the values of <span><em class="italic">i</em></span> where <span><em class="italic">a[i]</em></span> is true. </p>
<p class="calibre_1">Sometimes people squabble over whether programming is an art or a science. On the one hand, you have college curricula in <em class="italic">Computer Science</em>, and on the other hand, you have books such as Donald <a shape="rect"></a>Knuth's famous <a shape="rect"></a><em class="italic">The Art of Computer Programming</em> series. "Rather," wrote physicist Richard <a shape="rect"></a>Feynman, "computer science is like engineering—it is all about getting something to do something." </p>
<p class="calibre_1">If you ask 100 different people to write a program that prints out prime numbers, you'll get 100 different solutions. Even those programmers who use the <a shape="rect"></a>Sieve of Eratosthenes won't implement it in precisely the same way that I did. If programming truly were a science, there wouldn't be so many possible solutions, and incorrect solutions would be more obvious. Occasionally, a programming problem incites flashes of creativity and insight, and that's the "art" part. But programming is mostly a designing and building process not unlike erecting a bridge. </p>
<p class="calibre_1">Many of the early programmers were scientists and engineers who could be expected to formulate their problems in the mathematical algorithms required by <a shape="rect"></a>FORTRAN and ALGOL. Throughout the history of programming languages, however, people have tried creating languages that could be used by a wider range of people. </p>
<p class="calibre_1">One of the first successful languages designed for businesspeople and business problems was <a shape="rect"></a>COBOL (the COmmon Business Oriented Language), still widely used today. A committee that combined American industries and the defense department created COBOL beginning in 1959, influenced by Grace Hopper's early compilers. In part, COBOL was designed so that managers, while probably not doing the actual coding, could at least <span><em class="italic">read</em></span> the program code and check that it was doing what it was supposed to be doing. (In real life, however, this rarely occurs.) </p>
<p class="calibre_1">COBOL has extensive support for reading <span><em class="italic">records</em></span> and generating <span><em class="italic">reports</em></span>. Records are collections of information organized in a consistent manner. For example, an insurance company might maintain large files containing information on all the policies it has sold. Each policy would be a separate record. The record would include the person's name, a birth date, and other information. Many early COBOL programs were written to deal with 80-column records stored on IBM <a shape="rect"></a>punch cards. To use as little space as possible on these cards, calendar years were often coded as two digits rather than four, leading to the most common (but least publicized) instances of the infamous "millennium bug" as the year 2000 approached. </p>
<p class="calibre_1">In the mid-1960s, IBM, in connection with its System/360 project, developed a language named PL/I. (The I is actually a Roman numeral and pronounced <span><em class="italic">one</em></span>, so PL/I really stands for Programming Language Number One.) PL/I was intended to incorporate the block structure of ALGOL, the scientific and mathematics functions of <a shape="rect"></a>FORTRAN, and the record and report capabilities of COBOL. But the language never quite achieved the popularity of FORTRAN and COBOL. </p>
<p class="calibre_1">Although versions of FORTRAN, ALGOL, COBOL, and PL/I were available for home computers, none of them had quite the impact on small machines that BASIC had. </p>
<p class="calibre_1">BASIC (Beginner's All-purpose Symbolic Instruction Code) was developed in 1964 by John <a shape="rect"></a>Kemeny and Thomas <a shape="rect"></a>Kurtz, of the Dartmouth Mathematics Department, in connection with Dartmouth's time-sharing system. Most students at Dartmouth weren't math or engineering majors and hence couldn't be expected to mess around with punch cards and difficult program syntax. A Dartmouth student sitting at a terminal could create a BASIC program by simply typing BASIC statements preceded by numbers. The numbers indicated the order of the statements in the program. Statements not preceded by numbers were commands to the system such as <span><em class="italic">SAVE</em></span> (save the BASIC program to disk), <span><em class="italic">LIST</em></span> (display the lines in order), and <span><em class="italic">RUN</em></span> (compile and run the program). The first BASIC program in the first published BASIC instruction manual was </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">10 LET X = (7 + 8) / 3<br class="calibre30"/>20 PRINT X<br class="calibre30"/>30 END</tt></div></div><p class="calibre_1">Unlike <a shape="rect"></a>ALGOL, BASIC didn't require the programmer to specify whether a variable was to be stored as an integer or a floating-point value. Most numbers were stored as floating-point values without the programmer needing to worry about it. </p>
<p class="calibre_1">Many subsequent implementations of BASIC have been in the form of <span><em class="italic">interpreters</em></span> rather than <span><em class="italic">compilers</em></span>. As I explained earlier, a compiler reads a source-code file and creates an executable file. An interpreter, however, reads source code and executes it directly as it's reading it without creating an executable file. Interpreters are easier to write than compilers, but the execution time of the interpreted program tends to be slower than that of a compiled program. On home computers, BASIC got an early start when buddies Bill <a shape="rect"></a>Gates (born 1955) and Paul <a shape="rect"></a>Allen (born 1953) wrote a BASIC interpreter for the <a shape="rect"></a>Altair 8800 in 1975 and jump-started their company, <a shape="rect"></a>Microsoft Corporation. </p>
<p class="calibre_1">The <a shape="rect"></a>Pascal programming language, which inherited much of its structure from ALGOL but included record handling from COBOL, was designed in the late 1960s by Swiss computer science professor Niklaus <a shape="rect"></a>Wirth (born 1934). Pascal was quite popular for IBM PC programmers, but in a very specific form—the product Turbo Pascal, introduced by Borland International in 1983 for the bargain price of $49.95. Turbo Pascal (written by Danish student Anders Hejlsberg, born in 1960) was a version of Pascal that came complete with an <span><em class="italic">integrated development environment</em></span>. The text editor and the compiler were combined in a single program that facilitated very fast programming. Integrated development environments had been popular on large mainframe computers, but Turbo Pascal heralded their arrival on small machines. </p>
<p class="calibre_1">Pascal was also a major influence on Ada, a language developed for use by the United States Department of Defense. The language was named after Augusta Ada <a shape="rect"></a>Byron, whom I mentioned in <a shape="rect" href="index_split_021.html#filepos1065365">Chapter 18</a> as the chronicler of Charles <a shape="rect"></a>Babbage's <a shape="rect"></a>Analytical Engine. </p>
<p class="calibre_1">And then there's C, a much-beloved programming language created between 1969 and 1973 largely by Dennis M. <a shape="rect"></a>Ritchie at <a shape="rect"></a>Bell Telephone Laboratories. People often ask why the language is called C. The simple answer is that it was derived from an early language called B, which was a simplified version of BCPL (Basic CPL), which was derived from CPL (Combined Programming Language). </p>
<p class="calibre_1">I mentioned in <a shape="rect" href="index_split_025.html#filepos1600607">Chapter 22</a> that the <a shape="rect"></a>UNIX operating system was designed to be portable. Most operating systems at the time were written in assembly language for a specific processor. In 1973, UNIX was written (or rather, rewritten) in C, and since then the operating system and the language have been closely identified. </p>
<p class="calibre_1">C is generally a very terse language. For example, instead of the words <span><em class="italic">begin</em></span> and <span><em class="italic">end</em></span> used in ALGOL and Pascal to delimit blocks, C uses the curly braces { and }. Here's another example. It's very common for a programmer to add a constant amount to a variable: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">i = i + 5;</tt></div></div><p class="calibre_1">In C, you can shorten this to</p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">i += 5;</tt></div></div><p class="calibre_1">If you only need to add 1 to the variable (that is, to increment it), you can shorten the statement even further:</p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">i++;</tt></div></div><p class="calibre_1">On 16-bit or 32-bit microprocessors, such a statement can be carried out by a single machine-code instruction.</p>
<p class="calibre_1">I mentioned earlier that most high-level languages don't include bit-shifting operations or Boolean operations on bits, which are features supported by many processors. C is the exception to this rule. In addition, an important feature of C is its support of <span><em class="italic">pointers</em></span>, which are essentially numeric memory addresses. Because C has operations that parallel many common processor instructions, C is sometimes categorized as a <span><em class="italic">high-level assembly language</em></span>. More than any ALGOL-like language, C closely mimics common processor instruction sets. </p>
<p class="calibre_1">Yet <span><em class="italic">all</em></span> ALGOL-like languages—which really means <span><em class="italic">most</em></span> commonly used programming languages—were designed based on von Neumann architecture computers. Breaking out of the von Neumann mind-set when designing a computer language isn't easy, and getting other people to use such a language is even harder. One such non–von Neumann language is LISP (which stands for List Processing), which was designed by John McCarthy in the late 1950s and is useful for work in the field of artificial intelligence. Another language that's just as unusual but nothing like LISP is APL (A Programming Language), developed in the late 1950s by Kenneth Iverson. APL uses a collection of odd symbols that perform operations on whole arrays of numbers at once. </p>
<p class="calibre_1">While ALGOL-like languages have retained their dominance, in recent years they've picked up certain enhancements that have resulted in what are called <span><em class="italic">object-oriented</em></span> languages. These languages are useful for working with the graphical operating systems that I'll describe in the next (and last) chapter. </p>
</div>  <div class="mbp_pagebreak" id="calibre_pb_80"></div>
</body></html>
