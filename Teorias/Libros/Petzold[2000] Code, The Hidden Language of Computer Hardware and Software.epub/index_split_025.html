<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Code: The Hidden Language of Computer Hardware and Software</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre">
<div id="filepos1600607" style="height:0pt"></div><div id="filepos1600607" class="calibre_">
<div class="calibre_">
<div class="calibre_">
<div class="calibre_">
<h1 class="calibre1" id="calibre_pb_73"><span class="calibre2"><a shape="rect" class="calibre4"></a>Chapter 22. The Operating System </span></h1>
</div>
</div>
</div>
<p class="calibre_1">We have, at long last, assembled—at least in our imaginations—what seems to be a complete computer. This computer has a microprocessor, some random access memory, a keyboard, a video display, and a disk drive. All the hardware is in place, and we eye with excitement the on/off switch that will power it up and bring it to life. Perhaps this project has evoked in your mind the labors of Victor Frankenstein as he assembled his monster, or Geppetto as he built the wooden puppet that he will name Pinocchio. </p>
<p class="calibre_1">But still we're missing something, and it's neither the power of a lightning bolt nor the purity of a wish upon a star. Go ahead: Turn on this new computer and tell me what you see. </p>
<p class="calibre_1">As the cathode-ray tube warms up, the screen displays an array of perfectly formed—but totally random—ASCII characters. This is as we expect. Semiconductor memory loses its contents when the power is off and begins in a random and unpredictable state when it first gets power. Likewise, all the RAM that we've constructed for the microprocessor contains random bytes. The microprocessor begins executing these random bytes as if they were machine code. This won't cause anything <span><em class="italic">bad</em></span> to happen—the computer won't blow up, for instance—but it won't be very productive either. </p>
<p class="calibre_1">What we're missing here is software. When a microprocessor is first turned on or reset, it begins executing machine code at a particular memory address. In the case of the <a shape="rect"></a>Intel 8080, that address is 0000h. In a properly designed computer, that memory address should contain a machine-code instruction (most likely the first of many) when the computer is turned on. </p>
<p class="calibre_1">How does that <a shape="rect"></a>machine-code instruction get there? The process of getting software into a newly designed computer is possibly one of the most confusing aspects of the project. One way to do it is with a control panel similar to the one in <a shape="rect" href="index_split_019.html#filepos880943">Chapter 16</a> used for writing bytes into random access memory and later reading them: </p>
<div class="calibre_">
<div class="calibre_"><a shape="rect"></a><img alt="image with no caption" src="images/00412.jpg" class="calibre10"/></div>
</div>
<p class="calibre_1">Unlike the earlier control panel, this one has a switch labeled Reset. The Reset switch is connected to the Reset input of the microprocessor. As long as that switch is on, the microprocessor doesn't do anything. When you turn off the switch, the microprocessor begins executing <a shape="rect"></a>machine code. </p>
<p class="calibre_1">To use this control panel, you turn the Reset switch on to reset the microprocessor and to stop it from executing machine code. You turn on the Takeover switch to take over the address signals and data signals on the bus. At this time, you can use the switches labeled A<sub class="calibre25">0</sub> through A<sub class="calibre25">15</sub> to specify a 16-bit memory address. The lightbulbs labeled D<sub class="calibre25">0</sub> through D<sub class="calibre25">7</sub> show you the 8-bit contents of that memory address. To write a new byte into that address, you set the byte up on switches D<sub class="calibre25">0</sub> through D<sub class="calibre25">7</sub> and flip the Write switch on and then off again. After you're finished inserting bytes into memory, turn the Takeover switch off and the Reset switch off, and the microprocessor will execute the program. </p>
<p class="calibre_1">This is how you enter your first machine-code programs into a computer that you've just built from scratch. That it's laborious goes without saying. That you will make little mistakes now and then is a given. That your fingers will get blisters and your brain will turn to mush is an occupational hazard. </p>
<p class="calibre_1">But what makes it all worthwhile happens when you start to use the <a shape="rect"></a>video display to show the results of your programs. The text-only video display we built in the last chapter has 1 kilobyte of random access memory that's used to store the ASCII codes of 25 lines of 40 characters each. A program writes to this memory the same way that it writes to any other memory in the computer. </p>
<p class="calibre_1">But getting program output to the video display isn't as simple as it might first seem. If, for example, a program that you write does a particular calculation that results in the value 4Bh, you can't simply write that value to the video display memory. What you'll see in the screen in that case is the letter K because that's the letter that corresponds to the ASCII code 4Bh. Instead, you need to write <span><em class="italic">two</em></span> ASCII characters to the display: 34h, which is the ASCII code for 4, and 42h, which is the ASCII code for B. Each nibble of the 8-bit result is a hexadecimal digit, which must be displayed by the ASCII code for that digit. </p>
<p class="calibre_1">Of course, you'll probably write little subroutines that perform this conversion. Here's one in 8080 assembly language that converts a nibble in the accumulator (assumed to be a value between 00h and 0Fh inclusive) to its ASCII equivalent: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">NibbleToAscii: CPI A,0Ah ; Check if it's a letter or number<br class="calibre30"/>               JC Number<br class="calibre30"/>               ADD A,37h ; A to F converted to 41h to 46h<br class="calibre30"/>               RET<br class="calibre30"/>Number:        ADD A,30h ; 0 to 9 converted to 30h to 39h<br class="calibre30"/>               RET</tt></div></div><p class="calibre_1">This subroutine calls <span><em class="italic">NibbleToAscii</em></span> twice to convert a byte in accumulator A to two ASCII digits in registers B and C: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">ByteToAscii: PUSH PSW           ; Save accumulator<br class="calibre30"/>             RRC                ; Rotate A right 4 times...<br class="calibre30"/>             RRC<br class="calibre30"/>             RRC<br class="calibre30"/>             RRC                ; ...to get high-order nibble<br class="calibre30"/>             CALL NibbleToAscii ; Convert to ASCII code<br class="calibre30"/>             MOV B,A            ; Move result to register B<br class="calibre30"/>             POP PSW            ; Get original A back<br class="calibre30"/>             AND A,0Fh          ; Get low-order nibble<br class="calibre30"/>             CALL NibbleToAscii ; Convert to ASCII code<br class="calibre30"/>             MOV C,A            ; Move result to register C<br class="calibre30"/>             RET</tt></div></div><p class="calibre_1">These subroutines now let you display a byte in hexadecimal on the video display. If you want to convert to decimal, it's a bit more work. The process is actually quite similar to the way a person converts hexadecimal to decimal—by several divisions by 10. </p>
<p class="calibre_1">Remember that you're not actually entering these assembly-language programs into memory. Instead, you're probably writing them on paper and then converting them to machine code that you then enter into memory. This "hand assembling" is something that we'll continue doing until <a shape="rect" href="index_split_027.html#filepos1727052">Chapter 24</a>. </p>
<p class="calibre_1">Although the control panel doesn't require a lot of hardware, what it also lacks is ease of use. The control panel has to be the absolute worst form of input and output ever devised. It's downright embarrassing that we're clever enough to build our own computer from scratch, yet we're still keying in numbers in 0s and 1s. The first priority has to be to get rid of the control panel. </p>
<p class="calibre_1">The key, of course, is the keyboard. We've constructed the computer keyboard so that every time a key is pressed, an interrupt to the microprocessor occurs. The interrupt controller chip that we've used in our computer causes the microprocessor to respond to this interrupt by executing a <span><em class="italic">RST</em></span> (<span><em class="italic">Restart</em></span>) instruction. Let's suppose that this is a <span><em class="italic">RST 1</em></span> instruction. This instruction causes the microprocessor to save the current program counter on the stack and to jump to address 0008h. Beginning at that address, you'll enter some code (using the control panel) that we'll call the <span><em class="italic">keyboard handler</em></span>. </p>
<p class="calibre_1">To get this all working right, you'll need some code that's executed when the microprocessor is reset. This is called <span><em class="italic">initialization</em></span> code. The <a shape="rect"></a>initialization code first sets the stack pointer so that the stack is located in a valid area of memory. The code then sets every byte in the video display memory to the hexadecimal value 20h, which is the ASCII space character. This procedure gets rid of all the random characters on the screen. The initialization code uses the <span><em class="italic">OUT</em></span> (<span><em class="italic">Output</em></span>) instruction to set the position of the cursor—the underline on the video display that shows you where the next character you type will be entered—to the first column of the first row. The next instruction is <span><em class="italic">EI</em></span> to enable interrupts so that the microprocessor can respond to the keyboard interrupt. That instruction is followed by a <span><em class="italic">HLT</em></span> to halt the microprocessor. </p>
<p class="calibre_1">And that's it for the initialization code. From now on, the computer will mostly be in a halted state resulting from executing the <span><em class="italic">HLT</em></span> instruction. The only event that can nudge the computer from the halted state is a Reset from the control panel or an interrupt from the keyboard. </p>
<p class="calibre_1">The keyboard handler is much longer than the initialization code. Here's where all the really useful stuff takes place.</p>
<p class="calibre_1">Whenever a key is pressed on the keyboard, the interrupt signal causes the microprocessor to jump from the <span><em class="italic">HLT</em></span> statement at the end of the initialization code to the keyboard handler. The keyboard handler uses the <span><em class="italic">IN</em></span> (<span><em class="italic">Input</em></span>) instruction to determine the key that has been pressed. The keyboard handler then does something based on which key has been pressed (that is, the keyboard handler <span><em class="italic">processes</em></span> each key) and then executes a <span><em class="italic">RET</em></span> (<span><em class="italic">Return</em></span>) instruction to go back to the <span><em class="italic">HLT</em></span> statement to await another keyboard interrupt. </p>
<p class="calibre_1">If the pressed key is a letter or a number or a punctuation mark, the keyboard handler uses the keyboard scan code, taking into account whether the Shift key is up or down, to determine the appropriate ASCII code. It then writes this ASCII code into the video display memory at the cursor position. This procedure is called <span><em class="italic">echoing</em></span> the key to the display. The cursor position is then incremented so that the cursor appears in the space after the character just displayed. In this way, someone can type a bunch of characters on the keyboard and they'll be displayed on the screen. </p>
<p class="calibre_1">If the key pressed is the Backspace key (corresponding to ASCII code 08h), the keyboard handler erases the character that was last written to the video display memory. (Erasing the character is simply a matter of writing ASCII code 20h—the space character—in that memory location.) It then moves the cursor backward one space. </p>
<p class="calibre_1">Usually a person typing at the keyboard types in a line of characters—using the Backspace key when necessary to correct mistakes—and then presses the Return key, often labeled Enter on computer keyboards. In the same way that pressing the Return key on an electric typewriter indicates that the typist is ready to go to the beginning of the next line, pressing the Enter key indicates that the typist is finished typing a line of text. </p>
<p class="calibre_1">When the keyboard handler processes the Return or Enter key (corresponding to ASCII code 0Dh), the line of text in the <a shape="rect"></a>video display memory is interpreted as a <span><em class="italic">command</em></span> to the computer, that is, something for the keyboard handler to do. The keyboard handler includes a <span><em class="italic">command processor</em></span> that understands (for example) three commands: <span><em class="italic">W, D</em></span>, and <span><em class="italic">R</em></span>. </p>
<p class="calibre_1">If the line of text begins with a <span><em class="italic">W</em></span>, the command means <span><em class="italic">Write</em></span> some bytes into memory. The line you type on the screen looks something like this: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">W 1020 35 4F 78 23 9B AC 67</tt></div></div><p class="calibre_1">This command instructs the command processor to write the hexadecimal bytes 35, 4F, and so on into the memory addresses beginning at address 1020h. For this job, the keyboard handler needs to convert ASCII codes to bytes—a reversal of the conversion I demonstrated earlier. </p>
<p class="calibre_1">If the line of text begins with a <span><em class="italic">D</em></span>, the command means <span><em class="italic">Display</em></span> some bytes in memory. The line you type on the screen looks like this: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">D 1030</tt></div></div><p class="calibre_1">The command processor responds by displaying the 11 bytes stored beginning at location 1030h. (I say <span><em class="italic">11 bytes</em></span> because that's how many will fit on a 40-characterwide display on the same line following the address.) You can use the <span><em class="italic">Display</em></span> command to examine the contents of memory. </p>
<p class="calibre_1">If the line of text begins with an <span><em class="italic">R</em></span>, the command means <span><em class="italic">Run</em></span>. Such a command looks like this: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">R 1000</tt></div></div><p class="calibre_1">and means "Run the program that's stored beginning at address 1000h." The command processor stores 1000h in the register pair HL and then executes the instruction <span><em class="italic">PCHL</em></span>, which loads the program counter from register pair HL, effectively jumping to that address. </p>
<p class="calibre_1">Getting this keyboard handler and command processor working is an important milestone. Once you have it, you no longer need suffer the indignity of the control panel. Typing bytes in from the keyboard is easier, faster, and classier. </p>
<p class="calibre_1">Of course, you still have the problem of all the code you've entered disappearing when you turn off the power. For that reason, you'll probably want to store all this new code in read-only memory, or ROM. In the last chapter, we obtained a ROM chip that contained all the dot patterns necessary for displaying ASCII characters on the video display. We assumed our chip was configured with this data during manufacture. You can also program ROM chips in the privacy of your home. <span><em class="italic">Programmable read-only memory</em></span> (PROM) chips are programmable only once. <span><em class="italic">Erasable programmable read-only memory</em></span> (EPROM) chips can be programmed and reprogrammed after being entirely erased by exposure to ultraviolet light. </p>
<p class="calibre_1">As you'll recall, we wired our RAM boards with a DIP switch that allows us to specify the starting address of the board. If you're working with an 8080 system, initially one of your RAM boards will be set for address 0000h. After you create a ROM, that ROM will occupy address 0000h and the RAM board can be switched to a higher address. </p>
<p class="calibre_1">The creation of the command processor is an important milestone not only because it provides a faster means to enter bytes into memory but also because the computer is now <span><em class="italic">interactive</em></span>. When you type something on the keyboard, the computer responds by displaying something on the screen. </p>
<p class="calibre_1">Once you have the command processor in ROM, you can start experimenting with writing data from memory to the disk drive (probably in chunks that correspond to the sector size of the disk) and reading the data back into memory. Storing programs and data on the disk is much safer than storing them in RAM (where they'll disappear if the power fails) and much more flexible than storing them in ROM. </p>
<p class="calibre_1">Eventually you might want to add some new commands to the command processor. For example, the <span><em class="italic">S</em></span> command stands for <span><em class="italic">Store</em></span>: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">S 2080 2 15 3</tt></div></div><p class="calibre_1">This command indicates that the block of memory beginning at address 2080h is to be stored on the disk on side 2, track 15, and sector 3. (The size of this memory block is dependent on the sector size of the disk.) Similarly, you can add a <span><em class="italic">Load</em></span> command: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">L 2080 2 15 3</tt></div></div><p class="calibre_1">to load the sector from the disk back into memory.</p>
<p class="calibre_1">Of course, you'll have to keep track of what you're storing where. You'll probably keep a pad and pencil handy for this purpose. Be careful: You can't just store some code located at one address and then later load it back into memory at another address and expect it to work. All the <span><em class="italic">Jump</em></span> and <span><em class="italic">Call</em></span> instructions will be wrong because they indicate the old addresses. Also, you might have a program that's longer than the sector size of your disk, so you need to store it in several sectors. Because some sectors on the disk might be occupied by other programs or data and some sectors might be free, the sectors in which you store a long program might not be consecutive on the disk. </p>
<p class="calibre_1">Eventually, you could decide that the manual clerical work involved in keeping track of where everything is stored on the disk is just too much. At this point, you're ready for a <span><em class="italic">file system</em></span>.<a shape="rect"></a></p>
<p class="calibre_1">A file system is a method of disk storage in which data is organized into <span><em class="italic">files</em></span>. A file is simply a collection of related data that occupies one or more sectors on the disk. Most important, each file is identified by a <span><em class="italic">name</em></span> that helps you remember what the file contains. You can think of the disk as resembling a file cabinet in which each file has a little tab that indicates the name of the file. </p>
<p class="calibre_1">A file system is almost always part of a larger collection of software known as an <span><em class="italic">operating system</em></span>. The keyboard handler and command processor we've been building in this chapter could certainly evolve into an operating system. But instead of trudging through that long evolutionary process, let's take a look instead at a real operating system and get a feel for what it does and how it works.<a shape="rect"></a></p>
<p class="calibre_1">Historically, the most important operating system for 8-bit microprocessors was CP/M (Control Program for Micros), written in the mid-1970s for the Intel 8080 microprocessor by Gary <a shape="rect"></a>Kildall (born 1942), who later founded Digital Research Incorporated (DRI). </p>
<p class="calibre_1">CP/M is stored on a disk. In the early days of CP/M, the most common medium for CP/M was a single-sided 8-inch diskette with 77 tracks, 26 sectors per track, and 128 bytes per sector. (That's a total of 256,256 bytes.) The first two tracks of the disk contain CP/M itself. I'll describe shortly how CP/M gets from the disk into the computer memory. </p>
<p class="calibre_1">The remaining 75 tracks on the CP/M disk are used for storing files. The CP/M file system is fairly simple, but it satisfies the two major requirements: First, each file on the disk is identified by a name. This name is also stored on the disk; indeed, all the information that CP/M needs to read these files is stored on the disk along with the files themselves. Second, files don't have to occupy consecutive sectors on a disk. It often happens that as files of various sizes are created and deleted, free space on the disk becomes fragmented. The ability of a file system to store a large file in nonconsecutive sectors is very useful. </p>
<p class="calibre_1">The sectors in the 75 tracks used for storing files are grouped into <span><em class="italic">allocation blocks</em></span>. Each allocation block contains 8 sectors, or 1024 bytes. There are 243 allocation blocks on the disk, numbered 0 through 242. </p>
<p class="calibre_1">The first two allocation blocks (a total of 2048 bytes) are used for the <span><em class="italic">directory</em></span>. The directory is the area of the disk that contains the names and some crucial information about every file stored on the disk. Each file stored on the disk requires a <span><em class="italic">directory entry</em></span> 32 bytes long. Because the total directory is just 2048 bytes, the diskette is limited to 2048 ÷ 32, or 64, files. </p>
<p class="calibre_1">Each 32-byte directory entry contains the following information:</p>
<div class="calibre_">
<table border="1" class="calibre13"><div class="calibre11">
<colgroup span="1" class="calibre14">
<col span="1" class="calibre15"/>
<col span="1" class="calibre15"/>
</colgroup>
<thead class="calibre16">
<tr class="calibre17">
<th rowspan="1" colspan="1" class="calibre18"><div class="calibre12"><p class="calibre_1"><span class="calibre9">
Bytes</span></p></div></th>
<th rowspan="1" colspan="1" class="calibre18"><div class="calibre12"><p class="calibre_1"><span class="calibre9">
Meaning</span></p></div></th>
</tr>
</thead>
<tbody class="calibre19">
<tr class="calibre17">
<td rowspan="1" colspan="1" border="1" class="calibre20"><div class="calibre12">
<p class="calibre_1">0</p>
</div></td>
<td rowspan="1" colspan="1" border="1" class="calibre20"><div class="calibre12">
<p class="calibre_1">Usually set to 0</p>
</div></td>
</tr>
<tr class="calibre17">
<td rowspan="1" colspan="1" border="1" class="calibre20"><div class="calibre12">
<p class="calibre_1">1–8</p>
</div></td>
<td rowspan="1" colspan="1" border="1" class="calibre20"><div class="calibre12">
<p class="calibre_1">Filename</p>
</div></td>
</tr>
<tr class="calibre17">
<td rowspan="1" colspan="1" border="1" class="calibre20"><div class="calibre12">
<p class="calibre_1">9–11</p>
</div></td>
<td rowspan="1" colspan="1" border="1" class="calibre20"><div class="calibre12">
<p class="calibre_1">File type</p>
</div></td>
</tr>
<tr class="calibre17">
<td rowspan="1" colspan="1" border="1" class="calibre20"><div class="calibre12">
<p class="calibre_1">12</p>
</div></td>
<td rowspan="1" colspan="1" border="1" class="calibre20"><div class="calibre12">
<p class="calibre_1">File extent</p>
</div></td>
</tr>
<tr class="calibre17">
<td rowspan="1" colspan="1" border="1" class="calibre20"><div class="calibre12">
<p class="calibre_1">13–14</p>
</div></td>
<td rowspan="1" colspan="1" border="1" class="calibre20"><div class="calibre12">
<p class="calibre_1">Reserved (set to 0)</p>
</div></td>
</tr>
<tr class="calibre17">
<td rowspan="1" colspan="1" border="1" class="calibre20"><div class="calibre12">
<p class="calibre_1">15</p>
</div></td>
<td rowspan="1" colspan="1" border="1" class="calibre20"><div class="calibre12">
<p class="calibre_1">Sectors in last block</p>
</div></td>
</tr>
<tr class="calibre17">
<td rowspan="1" colspan="1" border="1" class="calibre20"><div class="calibre12">
<p class="calibre_1">16–31</p>
</div></td>
<td rowspan="1" colspan="1" border="1" class="calibre20"><div class="calibre12">
<p class="calibre_1">Disk map</p>
</div></td>
</tr>
</tbody>
</div></table>
</div>
<p class="calibre_1">The first byte in the directory entry is used only when the file system can be shared by two or more people at the same time. Under CP/M, this byte is normally set to 0, as are bytes 13 and 14. </p>
<p class="calibre_1">Under CP/M, each file is identified with a two-part name. The first part is known as the <span><em class="italic">filename</em></span> and can have up to eight characters stored in bytes 1 through 8 of the directory entry; the second part is known as the <span><em class="italic">file type</em></span> and can have up to three characters stored in bytes 9 through 11. There are several standard file types. For example, <span><em class="italic">TXT</em></span> indicates a text file (that is, a file containing only ASCII codes), and <span><em class="italic">COM</em></span> (which is short for <span><em class="italic">command</em></span>) indicates a file containing 8080 machine-code instructions—a program. When specifying a file, the two parts are separated by a period, like this: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">MYLETTER.TXT<br class="calibre30"/>CALC.COM</tt></div></div><p class="calibre_1">This file-naming convention has come to be known as 8.3 (pronounced <span><em class="italic">eight dot three</em></span>), indicating the maximum eight letters before the period and the three letters after. </p>
<p class="calibre_1">The disk map of the directory entry indicates the allocation blocks in which the file is stored. Suppose the first four entries in the disk map are 14h, 15h, 07h, and 23h, and the rest are zeros. This means that the file occupies four allocation blocks, or 4 KB of space. The file might actually be a bit shorter. Byte 15 in the directory entry indicates how many 128-byte sectors are actually used in the last allocation block. </p>
<p class="calibre_1">The disk map is 16 bytes long; that length accommodates a file up to 16,384 bytes. A file longer than 16 KB must use multiple directory entries, which are called <span><em class="italic">extents</em></span>. In that case, byte 12 is set to 0 in the first directory entry, 1 in the second directory entry, and so forth. </p>
<p class="calibre_1">I mentioned text files. Text files are also called <span><em class="italic">ASCII files</em></span>, or <span><em class="italic">text-only files</em></span>, or <span><em class="italic">pure-ASCII files</em></span>, or something along those lines. A text file contains ASCII codes (including carriage return and linefeed codes) that correspond to text readable by human beings. A file that isn't a text file is called a <span><em class="italic">binary</em></span> file. A CP/M <span><em class="italic">COM</em></span> file is a binary file because it contains 8080 machine code. </p>
<p class="calibre_1">Suppose a file (a very small file) must contain three 16-bit numbers—for example, 5A48h, 78BFh, and F510h. A binary file with these three numbers is just 6 bytes long: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">48 5A BF 78 10 F5</tt></div></div><p class="calibre_1">Of course, that's the <a shape="rect"></a>Intel format for storing multibyte numbers. The least-significant byte comes first. A program written for Motorola processors might be more inclined to create the file this way: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">5A 48 78 BF F5 10</tt></div></div><p class="calibre_1">An ASCII text file storing these same four 16-bit values contains the bytes</p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">35 41 34 38 68 0D 0A 37 38 42 46 68 0D 0A 46 35 31 30 68 0D 0A</tt></div></div><p class="calibre_1">These bytes are ASCII codes for numbers and letters, where each number is terminated by a carriage return (0Dh) and a linefeed (0A) character. The text file is more conveniently displayed not as a string of bytes that happen to be ASCII codes, but as the characters themselves: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">5A48h<br class="calibre30"/>78BFh<br class="calibre30"/>F510h</tt></div></div><p class="calibre_1">An ASCII text file that stores these three numbers could also contain these bytes:</p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">32 33 31 31 32 0D 0A 33 30 39 31 31 0D 0A 36 32 37 33 36 0D 0A</tt></div></div><p class="calibre_1">These bytes are the ASCII codes for the decimal equivalents of the three numbers:</p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">23112<br class="calibre30"/>30911<br class="calibre30"/>62736</tt></div></div><p class="calibre_1">Since the intent of using text files is to make the files easier for humans to read, there's really no reason not to use decimal rather than hexadecimal numbers. </p>
<p class="calibre_1">As I mentioned, CP/M itself is stored on the first two tracks of a disk. To run, CP/M must be loaded from the disk into memory. The ROM in a computer that uses CP/M need not be extensive. All the ROM needs to contain is a small piece of code known as a <span><em class="italic">bootstrap loader</em></span> (because that code effectively pulls the rest of the <a shape="rect"></a>operating system up by its bootstraps). The bootstrap loader loads the very first 128-byte sector from the diskette into memory and runs it. This sector contains code to load the rest of CP/M into memory. The entire process is called <span><em class="italic">booting</em></span> the operating system. </p>
<p class="calibre_1">Eventually, CP/M arranges itself to occupy the area of RAM with the highest memory addresses. The entire organization of memory after CP/M has loaded looks like this: </p>
<div class="calibre_">
<div class="calibre_"><a shape="rect"></a><img alt="image with no caption" src="images/00413.jpg" class="calibre10"/></div>
</div>
<p class="calibre_1">This diagram isn't to scale. The three components of CP/M—the Basic Input/ Output System (BIOS), the Basic Disk Operating System (BDOS), and the Console Command Processor (CCP)—occupy only about 6 KB of memory in total. The Transient Program Area (TPA)—about 58 KB of memory in a 64-KB computer—initially contains nothing. </p>
<p class="calibre_1">The Console Command Processor is equivalent to the command processor that we were building earlier. The word <span><em class="italic">console</em></span> refers to a combination of a keyboard and a display. The CCP displays a <span><em class="italic">prompt</em></span> on the display, which looks like this: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">A&gt;</tt></div></div><p class="calibre_1">The prompt is your signal to type something in. In computers that have more than one disk drive, the A refers to the first disk drive, the one from which CP/M was loaded. You type in commands following the prompt and press the Enter key. The CCP then executes these commands, which usually produces information displayed on the screen. When the command has finished, the CCP displays the prompt again. </p>
<p class="calibre_1">The CPP recognizes just a few commands. Possibly the most important is this one:</p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">DIR</tt></div></div><p class="calibre_1">which displays the directory of the disk—that is, a list of all the files stored on the disk. You can use the special characters ? and * to limit this list to files of a particular name or type. For example, </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">DIR *.TXT</tt></div></div><p class="calibre_1">displays all text files, while</p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">DIR A???B.*</tt></div></div><p class="calibre_1">displays a list of all files that have a five-character name where the first letter is A and the last letter is B.</p>
<p class="calibre_1">Another command is <span><em class="italic">ERA</em></span>, which is short for <span><em class="italic">Erase</em></span>. You use this to erase a file from the disk. For example, </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">ERA MYLETTER.TXT</tt></div></div><p class="calibre_1">erases the file with that name, while</p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">ERA *.TXT</tt></div></div><p class="calibre_1">erases all text files. Erasing a file means freeing the directory entry and the disk space occupied by the file.</p>
<p class="calibre_1">Another command is <span><em class="italic">REN</em></span>, which is short for <span><em class="italic">Rename</em></span>. You use this command to change the name of a file. The <span><em class="italic">TYPE</em></span> command displays the contents of a text file. Because a text file contains only ASCII codes, this command allows you to read a file right on the screen, like this: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">TYPE MYLETTER.TXT</tt></div></div><p class="calibre_1">The <span><em class="italic">SAVE</em></span> command saves one or more 256-byte memory blocks located in the Transient Program Area to a disk file with a specified name. </p>
<p class="calibre_1">If you type in a command that CP/M doesn't recognize, it assumes you're specifying the name of a program that's stored as a file on the disk. Programs always have the file type <span><em class="italic">COM</em></span>, which stands for Command. The CCP searches for a file of that name on the disk. If one exists, CP/M loads the file from disk into the Transient Program Area, which begins at memory address 0100h. This is how you run programs that are located on the disk. For example, if you type </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">CALC</tt></div></div><p class="calibre_1">following the CP/M prompt, and if a file named <span><em class="italic">CALC.COM</em></span> exists on the disk, the CCP loads that file into memory starting at address 0100h and then executes the program by jumping to the machine-code instruction located at address 0100h. </p>
<p class="calibre_1">Earlier I explained how you can insert machine-code instructions any-where into memory and execute them, but in CP/M programs that are stored in disk files must be designed to be loaded into memory beginning at a specific memory location, which is 0100h. </p>
<p class="calibre_1">CP/M comes with several useful programs, including <span><em class="italic">PIP</em></span>, the Peripheral Interchange Program, which allows you to copy files. The <span><em class="italic">ED</em></span> program is a text editor that allows you to create and modify text files. Programs such as PIP and ED, which are small and designed to do simple chores, are often known as <span><em class="italic">utility</em></span> programs. If you were running a CP/M system, you would probably purchase larger <span><em class="italic">application</em></span> programs, such as word processors or computer spreadsheets. Or you might write such programs yourself. All these programs are also stored in files of the <span><em class="italic">COM</em></span> type. </p>
<p class="calibre_1">So far we've seen how CP/M (like most operating systems) provides commands and utilities that let you perform rudimentary housekeeping regarding files. We've also seen how CP/M loads program files into memory and executes them. An operating system also has a third major function. </p>
<p class="calibre_1">A program running under CP/M often needs to write some output to the video display. Or the program might need to read something that you've typed on the keyboard. Or the program might need to read a file from the disk or to write a file to the disk. But in most cases, the CP/M program does <span><em class="italic">not</em></span> write its output directly into video display memory. Likewise, the CP/M program does <span><em class="italic">not</em></span> access the hardware of the keyboard to see what you've typed. And the CP/M program definitely does <span><em class="italic">not</em></span> access the disk drive hard-ware to read and write disk sectors. </p>
<p class="calibre_1">Instead, a program running under CP/M makes use of a collection of subroutines built into CP/M for performing these common chores. These subroutines have been specifically designed so that programs can get easy access to all the hardware of the computer—including the video display, keyboard, and disk—without worrying programmers about how these peripherals are actually connected. Most important, a program running under CP/M doesn't <span><em class="italic">need</em></span> to know about disk sectors and tracks. That's CP/M's job. It can instead store whole files on the disk and later read them. </p>
<p class="calibre_1">Providing a program with easy access to the hardware of the computer is the third major function of an operating system. The access that the operating system provides is called the <span><em class="italic">application programming interface</em></span>, or API. </p>
<p class="calibre_1">A program running under CP/M uses the API by setting register C to a particular value (called the <span><em class="italic">function</em></span> value) and executing the instruction </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">CALL 5</tt></div></div><p class="calibre_1">For example, a program obtains the ASCII code of a key typed on the keyboard by executing</p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">MVI C,01h<br class="calibre30"/>CALL 5</tt></div></div><p class="calibre_1">On return, accumulator A contains the ASCII code of the key that was pressed. Similarly,</p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">MVI C,02h<br class="calibre30"/>CALL 5</tt></div></div><p class="calibre_1">writes the ASCII character in accumulator A to the video display at the cursor position and then increments the cursor.</p>
<p class="calibre_1">If a program needs to create a file, it sets register pair DE to an area of memory that basically contains the name of the file. Then it executes the code: </p><a shape="rect"></a><div class="calibre11"><div class="calibre_"><tt class="calibre29">MVI C,16h<br class="calibre30"/>CALL 5</tt></div></div><p class="calibre_1">In this case, the <span><em class="italic">CALL 5</em></span> instruction causes CP/M to create an empty file on the disk. The program can then use other functions to write to the file and eventually <span><em class="italic">close</em></span> the file, which means it has finished using the file for now. The same program or another program can later <span><em class="italic">open</em></span> the file and read its contents. </p>
<p class="calibre_1">What does <span><em class="italic">CALL 5</em></span> actually do? The memory location at 0005h is set up by CP/M to contain a <span><em class="italic">JMP</em></span> (<span><em class="italic">Jump</em></span>) instruction, which jumps to a location in the Basic Disk Operating System (BDOS) of CP/M. This area contains a bunch of subroutines that execute each of the CP/M functions. The BDOS—as its name implies—is primarily responsible for maintaining the file system on the disk. Frequently, the BDOS has to make use of subroutines in the Basic Input/Output System (BIOS) of CP/M, which is the area that actually accesses the hardware of the keyboard, the video display, and the disk drives. In fact, the BIOS is the only section of CP/M that needs to know about the hardware of the computer. The CCP does everything it needs to do using BDOS functions, and so do the utilities that come with CP/M. </p>
<p class="calibre_1">The API is a <span><em class="italic">device-independent</em></span> interface to the hardware of the computer. What this means is that a program written for CP/M doesn't need to know the actual mechanics of how the keyboard works on a particular machine, or how the video display works, or how to read and write disk sectors. It simply uses the CP/M functions to perform tasks that involve the keyboard, display, and disk. The bonus is that a CP/M program can run on many different computers that might use very different hardware to access these peripherals. (All CP/M programs must have an Intel 8080 microprocessor, however, or a processor that executes 8080 instructions, such as the Intel 8085 or the Zilog Z-80.) Just as long as the computer is running CP/M, the program uses the CP/M functions to indirectly access this hardware. Without standard APIs, programs would have to be specifically tailored to run on different types of computers. </p>
<p class="calibre_1">CP/M was once a very popular operating system for the 8080 and remains historically important. CP/M was the major influence behind a 16-bit operating system named QDOS (Quick and Dirty Operating System) written by Tim <a shape="rect"></a>Paterson of Seattle Computer Products for <a shape="rect"></a>Intel's 16-bit 8086 and 8088 chips. QDOS was eventually renamed 86-DOS and licensed by Microsoft Corporation. Under the name <a shape="rect"></a>MS-DOS (Microsoft Disk Operating System, pronounced <span><em class="italic">em ess dahs</em></span>, like the German article <span><em class="italic">das</em></span>), the operating system was licensed to IBM for the first IBM Personal Computer, introduced in 1981. Although a 16-bit version of CP/M (called CP/M-86) was also available for the IBM PC, <a shape="rect"></a>MS-DOS quickly became the standard. MS-DOS (called PC-DOS on IBM's computers) was also licensed to other manufacturers who created computers compatible with the IBM PC. </p>
<p class="calibre_1">MS-DOS didn't retain CP/M's file system. The file system in MS-DOS instead used a scheme called the File Allocation Table, or FAT, which had been originally invented at Microsoft in 1977. The disk space is divided into clusters, which—depending on the size of the disk—can range in size <a shape="rect"></a>from 512 bytes to 16,384 bytes. Each file is a collection of clusters. The directory entry for a file indicates only that file's <span><em class="italic">starting</em></span> cluster. The FAT itself indicates for each cluster on the disk what the next cluster is. </p>
<p class="calibre_1">The directory entries on an MS-DOS disk are 32 bytes long and use the same 8.3 filenaming convention as CP/M. The terminology is a little different, however: The last three letters are called the filename <span><em class="italic">extension</em></span> rather than the file type. The MS-DOS directory entry need not contain a list of allocation blocks. Instead, the directory includes such useful information as the date and time the file was last modified, and the size of the file. </p>
<p class="calibre_1">The early versions of MS-DOS were structured much like CP/M. But the BIOS wasn't required in MS-DOS because the IBM PC itself included a complete BIOS in ROM. The command processor in MS-DOS is a file named COMMAND.COM. MS-DOS programs come in two flavors. Programs with the filename extension COM are limited to 64 KB in size. Larger programs have the filename extension EXE (pronounced <span><em class="italic">eks-ee</em></span>, for executable). </p>
<p class="calibre_1">Although MS-DOS initially supported the <span><em class="italic">CALL 5</em></span> interface for API functions, a newer interface was recommended for new programs. The newer interface used a feature of the 8086 called the <span><em class="italic">software interrupt</em></span>, which is similar to a subroutine call except that the program doesn't need to know the actual address that it's calling. A program calls an MS-DOS API function by executing the instruction <span><em class="italic">INT 21h</em></span> (pronounced <span><em class="italic">int twenty—one</em></span>, even though it's hexadecimal). </p>
<p class="calibre_1">In theory, application programs are supposed to access the hardware of the computer only through the interfaces provided by the operating system. But many application programmers who dealt with small computer operating systems of the 1970s and early 1980s often bypassed the operating system, particularly in dealing with the <a shape="rect"></a>video display. Programs that directly wrote bytes into video display memory ran faster than programs that didn't. Indeed, for some applications—such as those that needed to display graphics on the video display—the operating system was totally inadequate. What many programmers liked most about <a shape="rect"></a>MS-DOS was that it "stayed out of the way" and let programmers write programs as fast as the hardware allowed. </p>
<p class="calibre_1">For this reason, popular software that ran on the IBM PC often relied upon idiosyncrasies of the IBM PC hardware. Manufacturers of machines intended to be competitive with the IBM PC were often forced to duplicate these idiosyncrasies; not doing so would cause popular programs to run poorly, if at all. Such software often included the hardware requirement "IBM Personal Computer or 100 percent compatible" or something similar. </p>
<p class="calibre_1"><a shape="rect"></a>MS-DOS version 2.0, released in March 1983, was enhanced to accommodate hard disk drives, which at the time were small (by today's standards) but which would soon get much larger. The larger a disk drive, of course, the more <a shape="rect"></a>files it can store. And the more files a disk can store, the more confusing it becomes to find a particular file or to impose any type of organization on the files. </p>
<p class="calibre_1">The solution in MS-DOS 2.0 is called a <span><em class="italic">hierarchical file system</em></span>. This was added to the existing MS-DOS file system with a minimum number of changes. As you'll recall, a disk contains an area called a directory, which is a list of files that includes information about where the files are stored on the disk. In a hierarchical file system, some of these files might <span><em class="italic">themselves</em></span> be directories—that is, they're files that contain a list of other files. Some of these files might also be directories. The normal directory on the disk is called the <span><em class="italic">root directory</em></span>. Directories contained in other directories are called <span><em class="italic">subdirectories</em></span>. The directories (sometimes called <span><em class="italic">folders</em></span>) become a way to group related files. </p>
<p class="calibre_1">The hierarchical file system—and some other features of MS-DOS 2.0—were borrowed from an operating system named UNIX, which was developed in the early 1970s at <a shape="rect"></a>Bell Telephone Laboratories largely by Ken <a shape="rect"></a>Thompson (born 1943) and Dennis <a shape="rect"></a>Ritchie (born 1941). The funny name of the operating system is a play on words: UNIX was originally written as a less hardy version of an earlier operating system named <a shape="rect"></a>Multics (which stands for Multiplexed Information and Computing Services) that Bell Labs had been codeveloping with <a shape="rect"></a>MIT and GE. </p>
<p class="calibre_1">Among hard-core computer programmers, UNIX is the most beloved operating system of all time. While most operating systems are written for specific computers, UNIX was designed to be <span><em class="italic">portable</em></span>, which means that it can be adapted to run on a variety of computers. </p>
<p class="calibre_1">Bell Labs was, of course, a subsidiary of American Telephone &amp; Telegraph at the time UNIX was developed, and therefore subject to court decrees intended to curb AT&amp;T's monopoly position in the telephone industry. Originally, AT&amp;T was prohibited from marketing UNIX; the company was obliged to license it to others. So beginning in 1973, UNIX was extensively licensed to universities, corporations, and the government. In 1983, AT&amp;T was allowed back into the computer business and released its own version of UNIX. </p>
<p class="calibre_1">The result is that there's no single version of UNIX. There are, instead, a variety of different versions known under different names running on different computers sold by different vendors. Lots of people have put their fingers into UNIX and left their fingerprints behind. Still, however, a prevalent "UNIX philosophy" seems to guide people as they add pieces to UNIX. Part of that philosophy is using text files as a common denominator. Many UNIX utilities read text files, do something with them, and then write another text file. UNIX utilities can be strung together in chains that do different types of processing on these text files. </p>
<p class="calibre_1">UNIX was originally written for computers that were too large and too expensive for just one person to use. Such computers allow multiple users to interact with them simultaneously through a technique known as <span><em class="italic">time-sharing</em></span>. The computer is connected to multiple displays and keyboards called <span><em class="italic">terminals</em></span>. By quickly switching attention among all the terminals, an operating system can make it seem as if the computer is servicing everyone at the same time. </p>
<p class="calibre_1">An operating system that runs multiple programs concurrently is known as a <span><em class="italic">multitasking</em></span> operating system, and obviously such an operating system is more complex than single-tasking operating systems such as CP/M and MS-DOS. Multitasking complicates the file system because multiple users might try to use the same files at the same time. It also affects how the computer allocates memory to the different programs, so some kind of <span><em class="italic">memory management</em></span> is required. As the multiple programs running concurrently need more memory, it's likely that the computer won't have enough memory to go around. The operating system might need to implement a technique called <span><em class="italic">virtual memory</em></span>, in which blocks of memory are stored in temporary files during periods when the memory blocks aren't needed and then read back into memory when they are needed. </p>
<p class="calibre_1">The most interesting development for UNIX in recent years has been the Free Software Foundation (FSF) and the GNU project, both founded by Richard Stallman. GNU (pronounced not like the animal but instead with a distinct G at the beginning) stands for "GNU's Not UNIX," which, of course, it's not. Instead, GNU is intended to be compatible with UNIX but distributed in a manner that prevents the software from becoming proprietary. The GNU project has resulted in many UNIX-compatible utilities and tools, and also Linux, which is the core (or <span><em class="italic">kernel</em></span>) of a UNIX-compatible operating system. Written largely by Linus Torvalds of Finland, Linux has become quite popular in recent years. </p>
<p class="calibre_1">The most significant trend in operating systems since the mid-1980s, however, has been the development of large and sophisticated systems, such as the Apple Macintosh and Microsoft Windows, that incorporate graphics and a visually rich video display intended to make applications easier to use. I'll describe this trend in the last chapter of this book. </p>
</div>  <div class="mbp_pagebreak" id="calibre_pb_74"></div>
</body></html>
